{
  "version": 3,
  "sources": ["../node_modules/.pnpm/es6-promisify@7.0.0/node_modules/es6-promisify/dist/promisify.js", "../node_modules/.pnpm/util@0.10.4/node_modules/util/support/isBufferBrowser.js", "../node_modules/.pnpm/inherits@2.0.3/node_modules/inherits/inherits_browser.js", "../node_modules/.pnpm/util@0.10.4/node_modules/util/util.js", "../node_modules/.pnpm/path@0.12.7/node_modules/path/path.js", "../src/path.js", "../src/constants.js", "../src/providers/indexeddb.js", "../lib/async.js", "../src/providers/memory.js", "../src/providers/index.js", "../src/errors.js", "../src/shell/environment.js", "../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js", "../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/assert-valid-pattern.ts", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/brace-expressions.ts", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/unescape.ts", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/ast.ts", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/escape.ts", "../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/src/index.ts", "../src/shell/shell.js", "../lib/eventemitter.js", "../src/shared.js", "../lib/intercom.js", "../src/fs-watcher.js", "../src/directory-entry.js", "../src/open-files.js", "../src/node.js", "../src/open-file-description.js", "../src/super-node.js", "../src/stats.js", "../src/dirent.js", "../src/filesystem/implementation.js", "../src/filesystem/interface.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/Range.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/hints.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/ValidationError.js", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/code.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/scope.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/util.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/names.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/errors.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/boolSchema.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/rules.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/applicability.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/dataType.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/defaults.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/code.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/keyword.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/subschema.ts", "../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js", "../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/resolve.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/validation_error.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/ref_error.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json", "../node_modules/.pnpm/fast-uri@3.0.1/node_modules/fast-uri/lib/scopedChars.js", "../node_modules/.pnpm/fast-uri@3.0.1/node_modules/fast-uri/lib/utils.js", "../node_modules/.pnpm/fast-uri@3.0.1/node_modules/fast-uri/lib/schemes.js", "../node_modules/.pnpm/fast-uri@3.0.1/node_modules/fast-uri/index.js", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/uri.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/core.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/id.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/ref.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/ucs2length.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitLength.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/pattern.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/required.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitItems.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/equal.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/const.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/enum.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/items.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/items2020.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/contains.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/properties.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/not.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/allOf.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/if.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/format/format.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/format/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/metadata.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/draft7.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/discriminator/types.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/discriminator/index.ts", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json", "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/ajv.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/typeof.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/typeof.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/instanceof.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/instanceof.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/_range.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/range.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/range.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/exclusiveRange.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/exclusiveRange.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/_util.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/regexp.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/regexp.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/transform.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/transform.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/uniqueItemProperties.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/uniqueItemProperties.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/allRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/allRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/_required.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/anyRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/anyRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/oneRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/oneRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/patternRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/patternRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/prohibited.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/prohibited.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/deepProperties.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/deepProperties.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/deepRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/deepRequired.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/dynamicDefaults.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/dynamicDefaults.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/definitions/select.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/select.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/keywords/index.ts", "../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/src/index.ts", "../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/src/formats.ts", "../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/src/limit.ts", "../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/src/index.ts", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/absolutePath.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/undefinedAsNull.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/validate.js", "../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/index.js", "../src/webpack-plugin/utils.js", "../src/webpack-plugin/schema.js", "../src/webpack-plugin/processors.js", "../src/webpack-plugin/index.js", "../src/index.js"],
  "sourcesContent": ["\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.promisify=promisify;var customArgumentsToken=\"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\";function promisify(a){if(\"function\"!=typeof a)throw new TypeError(\"Argument to promisify must be a function\");var b=a[customArgumentsToken],c=promisify.Promise||Promise;if(\"function\"!=typeof c)throw new Error(\"No Promise implementation found; do you need a polyfill?\");return function(){for(var d=this,e=arguments.length,f=Array(e),g=0;g<e;g++)f[g]=arguments[g];return new c(function(c,e){f.push(function(a){if(a)return e(a);for(var d=arguments.length,f=Array(1<d?d-1:0),g=1;g<d;g++)f[g-1]=arguments[g];if(1===f.length||!b)return c(f[0]);var h={};f.forEach(function(a,c){var d=b[c];d&&(h[d]=a)}),c(h)}),a.apply(d,f)})}}promisify.argumentNames=\"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\",promisify.Promise=void 0;\n", "module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}", "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n'use strict';\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = require('util');\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n", "/**\n * Patch process to add process.cwd(), always giving the root dir.\n * NOTE: this line needs to happen *before* we require in `path`.\n */\nprocess.cwd = () => '/';\n\n/**\n * https://github.com/browserify/path-browserify via Parcel.\n * We use is as a base for our own Filer.Path, and patch/add\n * a few things we need for the browser environment.\n */\nconst nodePath = require('path');\nconst filerPath = Object.assign({}, nodePath);\n\n/**\n * Patch path.basename() to return / vs. ''\n */\nfilerPath.basename = (path, ext) => {\n  const basename = nodePath.basename(path, ext);\n  return basename === '' ? '/' : basename;\n};\n\n/**\n * Patch path.normalize() to not add a trailing /\n */\nfilerPath.normalize = (path) => {\n  path = nodePath.normalize(path);\n  return path === '/' ? path : filerPath.removeTrailing(path);\n};\n\n/**\n * Add new utility method isNull() to path: check for null paths.\n */\nfilerPath.isNull = path => ('' + path).indexOf('\\u0000') !== -1;\n\n/**\n * Add new utility method addTrailing() to add trailing / without doubling to //.\n */\nfilerPath.addTrailing = path => path.replace(/\\/*$/, '/');\n\n/**\n * Add new utility method removeTrailing() to remove trailing /, dealing with multiple\n */\nfilerPath.removeTrailing = path => {\n  path = path.replace(/\\/*$/, '');\n  return path === '' ? '/' : path;\n};\n\nmodule.exports = filerPath;\n", "var O_READ = 'READ';\nvar O_WRITE = 'WRITE';\nvar O_CREATE = 'CREATE';\nvar O_EXCLUSIVE = 'EXCLUSIVE';\nvar O_TRUNCATE = 'TRUNCATE';\nvar O_APPEND = 'APPEND';\nvar XATTR_CREATE = 'CREATE';\nvar XATTR_REPLACE = 'REPLACE';\n\nmodule.exports = {\n  FILE_SYSTEM_NAME: 'local',\n\n  FILE_STORE_NAME: 'files',\n\n  IDB_RO: 'readonly',\n  IDB_RW: 'readwrite',\n\n  WSQL_VERSION: '1',\n  WSQL_SIZE: 5 * 1024 * 1024,\n  WSQL_DESC: 'FileSystem Storage',\n\n  NODE_TYPE_FILE: 'FILE',\n  NODE_TYPE_DIRECTORY: 'DIRECTORY',\n  NODE_TYPE_SYMBOLIC_LINK: 'SYMLINK',\n  NODE_TYPE_META: 'META',\n\n\n  DEFAULT_DIR_PERMISSIONS: 0x1ED, // 755\n  DEFAULT_FILE_PERMISSIONS: 0x1A4, // 644\n  FULL_READ_WRITE_EXEC_PERMISSIONS: 0x1FF, // 777\n  READ_WRITE_PERMISSIONS: 0x1B6, /// 666\n  \n  SYMLOOP_MAX: 10,\n\n  BINARY_MIME_TYPE: 'application/octet-stream',\n  JSON_MIME_TYPE: 'application/json',\n\n  ROOT_DIRECTORY_NAME: '/', // basename(normalize(path))\n\n  // FS Mount Flags\n  FS_FORMAT: 'FORMAT',\n  FS_NOCTIME: 'NOCTIME',\n  FS_NOMTIME: 'NOMTIME',\n  FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',\n\n  // FS File Open Flags\n  O_READ: O_READ,\n  O_WRITE: O_WRITE,\n  O_CREATE: O_CREATE,\n  O_EXCLUSIVE: O_EXCLUSIVE,\n  O_TRUNCATE: O_TRUNCATE,\n  O_APPEND: O_APPEND,\n\n  O_FLAGS: {\n    'r': [O_READ],\n    'r+': [O_READ, O_WRITE],\n    'w': [O_WRITE, O_CREATE, O_TRUNCATE],\n    'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],\n    'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'a': [O_WRITE, O_CREATE, O_APPEND],\n    'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],\n    'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],\n    'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]\n  },\n\n  XATTR_CREATE: XATTR_CREATE,\n  XATTR_REPLACE: XATTR_REPLACE,\n\n  FS_READY: 'READY',\n  FS_PENDING: 'PENDING',\n  FS_ERROR: 'ERROR',\n\n  SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',\n\n  // Reserved File Descriptors for streams\n  STDIN: 0,\n  STDOUT: 1,\n  STDERR: 2,\n  FIRST_DESCRIPTOR: 3,\n\n  ENVIRONMENT: {\n    TMP: '/tmp',\n    PATH: ''\n  },\n\n  // Duplicate Node's fs.constants\n  fsConstants: {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 512,\n    O_EXCL: 2048,\n    O_NOCTTY: 131072,\n    O_TRUNC: 1024,\n    O_APPEND: 8,\n    O_DIRECTORY: 1048576,\n    O_NOFOLLOW: 256,\n    O_SYNC: 128,\n    O_DSYNC: 4194304,\n    O_SYMLINK: 2097152,\n    O_NONBLOCK: 4,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_COPYFILE_EXCL: 1,\n    COPYFILE_EXCL: 1\n  }\n};\n", "var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar IDB_RW = require('../constants.js').IDB_RW;\nvar IDB_RO = require('../constants.js').IDB_RO;\n\nfunction IndexedDBContext(db, mode) {\n  this.db = db;\n  this.mode = mode;\n}\n\nIndexedDBContext.prototype._getObjectStore = function() {\n  if(this.objectStore) {\n    return this.objectStore;\n  }\n\n  var transaction = this.db.transaction(FILE_STORE_NAME, this.mode);\n  this.objectStore = transaction.objectStore(FILE_STORE_NAME);\n  return this.objectStore;\n};\n\nIndexedDBContext.prototype.clear = function(callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.clear();\n    request.onsuccess = function() {\n      callback();\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDBContext.prototype._get = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.get(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.getObject = function(key, callback) {\n  this._get(key, callback);\n};\nIndexedDBContext.prototype.getBuffer = function(key, callback) {\n  this._get(key, function(err, arrayBuffer) {\n    if(err) {\n      return callback(err);\n    }\n    callback(null, Buffer.from(arrayBuffer));\n  });\n};\n\nIndexedDBContext.prototype._put = function(key, value, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.put(value, key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.putObject = function(key, value, callback) {\n  this._put(key, value, callback);\n};\nIndexedDBContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var buf = uint8BackedBuffer.buffer;\n  this._put(key, buf, callback);\n};\n\nIndexedDBContext.prototype.delete = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.delete(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\n\nfunction IndexedDB(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nIndexedDB.isSupported = function() {\n  var indexedDB = global.indexedDB       ||\n                  global.mozIndexedDB    ||\n                  global.webkitIndexedDB ||\n                  global.msIndexedDB;\n  return !!indexedDB;\n};\n\nIndexedDB.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  try {\n    var indexedDB = global.indexedDB       ||\n                    global.mozIndexedDB    ||\n                    global.webkitIndexedDB ||\n                    global.msIndexedDB;\n\n    // NOTE: we're not using versioned databases.\n    var openRequest = indexedDB.open(that.name);\n\n    // If the db doesn't exist, we'll create it\n    openRequest.onupgradeneeded = function onupgradeneeded(event) {\n      var db = event.target.result;\n\n      if(db.objectStoreNames.contains(FILE_STORE_NAME)) {\n        db.deleteObjectStore(FILE_STORE_NAME);\n      }\n      db.createObjectStore(FILE_STORE_NAME);\n    };\n\n    openRequest.onsuccess = function onsuccess(event) {\n      that.db = event.target.result;\n      callback();\n    };\n    openRequest.onerror = function onerror(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDB.prototype.getReadOnlyContext = function() {\n  return new IndexedDBContext(this.db, IDB_RO);\n};\nIndexedDB.prototype.getReadWriteContext = function() {\n  return new IndexedDBContext(this.db, IDB_RW);\n};\n\nmodule.exports = IndexedDB;\n", "/*global setImmediate: false, setTimeout: false, console: false */\n\n/**\n * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014\n * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE\n */\n\n(function () {\n\n    var async = {};\n\n    // async.js functions used in Filer\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n", "var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\n// NOTE: prefer setImmediate to nextTick for proper recursion yielding.\n// see https://github.com/js-platform/filer/pull/24\nvar asyncCallback = require('../../lib/async.js').setImmediate;\n\n/**\n * Make shared in-memory DBs possible when using the same name.\n */\nvar createDB = (function() {\n  var pool = {};\n  return function getOrCreate(name) {\n    if(!Object.prototype.hasOwnProperty.call(pool, name)) {\n      pool[name] = {};\n    }\n    return pool[name];\n  };\n}());\n\nfunction MemoryContext(db, readOnly) {\n  this.readOnly = readOnly;\n  this.objectStore = db;\n}\n\nMemoryContext.prototype.clear = function(callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  var objectStore = this.objectStore;\n  Object.keys(objectStore).forEach(function(key){\n    delete objectStore[key];\n  });\n  asyncCallback(callback);\n};\n\n// Memory context doesn't care about differences between Object and Buffer\nMemoryContext.prototype.getObject =\nMemoryContext.prototype.getBuffer =\nfunction(key, callback) {\n  var that = this;\n  asyncCallback(function() {\n    callback(null, that.objectStore[key]);\n  });\n};\nMemoryContext.prototype.putObject =\nMemoryContext.prototype.putBuffer =\nfunction(key, value, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  this.objectStore[key] = value;\n  asyncCallback(callback);\n};\n\nMemoryContext.prototype.delete = function(key, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  delete this.objectStore[key];\n  asyncCallback(callback);\n};\n\n\nfunction Memory(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n}\nMemory.isSupported = function() {\n  return true;\n};\n\nMemory.prototype.open = function(callback) {\n  this.db = createDB(this.name);\n  asyncCallback(callback);\n};\nMemory.prototype.getReadOnlyContext = function() {\n  return new MemoryContext(this.db, true);\n};\nMemory.prototype.getReadWriteContext = function() {\n  return new MemoryContext(this.db, false);\n};\n\nmodule.exports = Memory;\n", "const IndexedDB = require('./indexeddb.js');\nconst Memory = require('./memory.js');\n\nmodule.exports = {\n  IndexedDB: IndexedDB,\n  Default: IndexedDB,\n  Memory: Memory\n};\n", "var errors = {};\n[\n  /**\n   * node.js errors - we only use some of these, add as needed.\n   */\n  //'-1:UNKNOWN:unknown error',\n  //'0:OK:success',\n  //'1:EOF:end of file',\n  //'2:EADDRINFO:getaddrinfo error',\n  '3:EACCES:permission denied',\n  //'4:EAGAIN:resource temporarily unavailable',\n  //'5:EADDRINUSE:address already in use',\n  //'6:EADDRNOTAVAIL:address not available',\n  //'7:EAFNOSUPPORT:address family not supported',\n  //'8:EALREADY:connection already in progress',\n  '9:EBADF:bad file descriptor',\n  '10:EBUSY:resource busy or locked',\n  //'11:ECONNABORTED:software caused connection abort',\n  //'12:ECONNREFUSED:connection refused',\n  //'13:ECONNRESET:connection reset by peer',\n  //'14:EDESTADDRREQ:destination address required',\n  //'15:EFAULT:bad address in system call argument',\n  //'16:EHOSTUNREACH:host is unreachable',\n  //'17:EINTR:interrupted system call',\n  '18:EINVAL:invalid argument',\n  //'19:EISCONN:socket is already connected',\n  //'20:EMFILE:too many open files',\n  //'21:EMSGSIZE:message too long',\n  //'22:ENETDOWN:network is down',\n  //'23:ENETUNREACH:network is unreachable',\n  //'24:ENFILE:file table overflow',\n  //'25:ENOBUFS:no buffer space available',\n  //'26:ENOMEM:not enough memory',\n  '27:ENOTDIR:not a directory',\n  '28:EISDIR:illegal operation on a directory',\n  //'29:ENONET:machine is not on the network',\n  // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'31:ENOTCONN:socket is not connected',\n  //'32:ENOTSOCK:socket operation on non-socket',\n  //'33:ENOTSUP:operation not supported on socket',\n  '34:ENOENT:no such file or directory',\n  //'35:ENOSYS:function not implemented',\n  //'36:EPIPE:broken pipe',\n  //'37:EPROTO:protocol error',\n  //'38:EPROTONOSUPPORT:protocol not supported',\n  //'39:EPROTOTYPE:protocol wrong type for socket',\n  //'40:ETIMEDOUT:connection timed out',\n  //'41:ECHARSET:invalid Unicode character',\n  //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n  // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'44:EAISERVICE:servname not supported for ai_socktype',\n  //'45:EAISOCKTYPE:ai_socktype not supported',\n  //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n  '47:EEXIST:file already exists',\n  //'48:ESRCH:no such process',\n  //'49:ENAMETOOLONG:name too long',\n  '50:EPERM:operation not permitted',\n  '51:ELOOP:too many symbolic links encountered',\n  //'52:EXDEV:cross-device link not permitted',\n  '53:ENOTEMPTY:directory not empty',\n  //'54:ENOSPC:no space left on device',\n  '55:EIO:i/o error',\n  //'56:EROFS:read-only file system',\n  //'57:ENODEV:no such device',\n  //'58:ESPIPE:invalid seek',\n  //'59:ECANCELED:operation canceled',\n\n  /**\n   * Filer specific errors\n   */\n  '1000:ENOTMOUNTED:not mounted',\n  '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n  '1002:ENOATTR:attribute does not exist'\n\n].forEach(function(e) {\n  e = e.split(':');\n  var errno = +e[0];\n  var errName = e[1];\n  var defaultMessage = e[2];\n\n  function FilerError(msg, path) {\n    Error.call(this);\n\n    this.name = errName;\n    this.code = errName;\n    this.errno = errno;\n    this.message = msg || defaultMessage;\n    if(path) {\n      this.path = path;\n    }\n    this.stack = (new Error(this.message)).stack;\n  }\n  FilerError.prototype = Object.create(Error.prototype);\n  FilerError.prototype.constructor = FilerError;\n  FilerError.prototype.toString = function() {\n    var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n    return this.name + ': ' + this.message + pathInfo;\n  };\n\n  // We expose the error as both Errors.EINVAL and Errors[18]\n  errors[errName] = errors[errno] = FilerError;\n});\n\nmodule.exports = errors;\n", "'use strict'; \nconst defaults = require('../constants.js').ENVIRONMENT;\n\nmodule.exports = function Environment(env) {\n  env = env || {};\n  env.TMP = env.TMP || defaults.TMP;\n  env.PATH = env.PATH || defaults.PATH;\n\n  this.get = function(name) {\n    return env[name];\n  };\n\n  this.set = function(name, value) {\n    env[name] = value;\n  };\n};\n", "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "var {promisify} = require('es6-promisify');\nvar Path = require('../path.js');\nvar Errors = require('../errors.js');\nvar Environment = require('./environment.js');\nvar async = require('../../lib/async.js');\nvar minimatch = require('minimatch');\n\nfunction Shell(fs, options) {\n  options = options || {};\n\n  var env = new Environment(options.env);\n  var cwd = '/';\n\n  /**\n   * The bound FileSystem (cannot be changed)\n   */\n  Object.defineProperty(this, 'fs', {\n    get: function() { return fs; },\n    enumerable: true\n  });\n\n  /**\n   * The shell's environment (e.g., for things like\n   * path, tmp, and other env vars). Use env.get()\n   * and env.set() to work with variables.\n   */\n  Object.defineProperty(this, 'env', {\n    get: function() { return env; },\n    enumerable: true\n  });\n\n  /**\n   * Change the current working directory. We\n   * include `cd` on the `this` vs. proto so that\n   * we can access cwd without exposing it externally.\n   */\n  this.cd = function(path, callback) {\n    path = Path.resolve(cwd, path);\n    // Make sure the path actually exists, and is a dir\n    fs.stat(path, function(err, stats) {\n      if(err) {\n        callback(new Errors.ENOTDIR(null, path));\n        return;\n      }\n      if(stats.type === 'DIRECTORY') {\n        cwd = path;\n        callback();\n      } else {\n        callback(new Errors.ENOTDIR(null, path));\n      }\n    });\n  };\n\n  /**\n   * Get the current working directory (changed with `cd()`)\n   */\n  this.pwd = function() {\n    return cwd;\n  };\n\n  this.promises = {};\n  /**\n  * Public API for Shell converted to Promise based\n  */\n  [\n    'cd',\n    'exec',\n    'touch',\n    'cat',\n    'ls',\n    'rm',\n    'tempDir',\n    'mkdirp',\n    'find'\n  ].forEach((methodName)=>{\n    this.promises[methodName] = promisify(this[methodName].bind(this));\n  });\n}\n\n/**\n * Execute the .js command located at `path`. Such commands\n * should assume the existence of 3 arguments, which will be\n * defined at runtime:\n *\n *   * fs - the current shell's bound filesystem object\n *   * args - a list of arguments for the command, or an empty list if none\n *   * callback - a callback function(error, result) to call when done.\n *\n * The .js command's contents should be the body of a function\n * that looks like this:\n *\n * function(fs, args, callback) {\n *   // .js code here\n * }\n */\nShell.prototype.exec = function(path, args, callback) {\n  /* jshint evil:true */\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof args === 'function') {\n    callback = args;\n    args = [];\n  }\n  args = args || [];\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  fs.readFile(path, 'utf8', function(error, data) {\n    if(error) {\n      callback(error);\n      return;\n    }\n    try {\n      var cmd = new Function('fs', 'args', 'callback', data);\n      cmd(fs, args, callback);\n    } catch(e) {\n      callback(e);\n    }\n  });\n};\n\n/**\n * Create a file if it does not exist, or update access and\n * modified times if it does. Valid options include:\n *\n *  * updateOnly - whether to create the file if missing (defaults to false)\n *  * date - use the provided Date value instead of current date/time\n */\nShell.prototype.touch = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  function createFile(path) {\n    fs.writeFile(path, '', callback);\n  }\n\n  function updateTimes(path) {\n    var now = Date.now();\n    var atime = options.date || now;\n    var mtime = options.date || now;\n\n    fs.utimes(path, atime, mtime, callback);\n  }\n\n  fs.stat(path, function(error) {\n    if(error) {\n      if(options.updateOnly === true) {\n        callback();\n      } else {\n        createFile(path);\n      }\n    } else {\n      updateTimes(path);\n    }\n  });\n};\n\n/**\n * Concatenate multiple files into a single String, with each\n * file separated by a newline. The `files` argument should\n * be a String (path to single file) or an Array of Strings\n * (multiple file paths).\n */\nShell.prototype.cat = function(files, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var all = '';\n  callback = callback || function(){};\n\n  if(!files) {\n    callback(new Errors.EINVAL('Missing files argument'));\n    return;\n  }\n\n  files = typeof files === 'string' ? [ files ] : files;\n\n  function append(item, callback) {\n    var filename = Path.resolve(sh.pwd(), item);\n    fs.readFile(filename, 'utf8', function(error, data) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      all += data + '\\n';\n      callback();\n    });\n  }\n\n  async.eachSeries(files, append, function(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, all.replace(/\\n$/, ''));\n    }\n  });\n};\n\n/**\n * Get the listing of a directory, returning an array of\n * file entries in the following form:\n *\n * {\n *   path: <String> the basename of the directory entry\n *   links: <Number> the number of links to the entry\n *   size: <Number> the size in bytes of the entry\n *   modified: <Number> the last modified date/time\n *   type: <String> the type of the entry\n *   contents: <Array> an optional array of child entries\n * }\n *\n * By default ls() gives a shallow listing. If you want\n * to follow directories as they are encountered, use\n * the `recursive=true` option.\n */\nShell.prototype.ls = function(dir, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!dir) {\n    callback(new Errors.EINVAL('Missing dir argument'));\n    return;\n  }\n\n  function list(path, callback) {\n    var pathname = Path.resolve(sh.pwd(), path);\n    var result = [];\n\n    fs.readdir(pathname, function(error, entries) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      function getDirEntry(name, callback) {\n        name = Path.join(pathname, name);\n        fs.stat(name, function(error, stats) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          var entry = stats;\n\n          if(options.recursive && stats.type === 'DIRECTORY') {\n            list(Path.join(pathname, entry.name), function(error, items) {\n              if(error) {\n                callback(error);\n                return;\n              }\n              entry.contents = items;\n              result.push(entry);\n              callback();\n            });\n          } else {\n            result.push(entry);\n            callback();\n          }\n        });\n      }\n\n      async.eachSeries(entries, getDirEntry, function(error) {\n        callback(error, result);\n      });\n    });\n  }\n\n  list(dir, callback);\n};\n\n/**\n * Removes the file or directory at `path`. If `path` is a file\n * it will be removed. If `path` is a directory, it will be\n * removed if it is empty, otherwise the callback will receive\n * an error. In order to remove non-empty directories, use the\n * `recursive=true` option.\n */\nShell.prototype.rm = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function remove(pathname, callback) {\n    pathname = Path.resolve(sh.pwd(), pathname);\n    fs.stat(pathname, function(error, stats) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      // If this is a file, delete it and we're done\n      if(stats.type === 'FILE') {\n        fs.unlink(pathname, callback);\n        return;\n      }\n\n      // If it's a dir, check if it's empty\n      fs.readdir(pathname, function(error, entries) {\n        if(error) {\n          callback(error);\n          return;\n        }\n\n        // If dir is empty, delete it and we're done\n        if(entries.length === 0) {\n          fs.rmdir(pathname, callback);\n          return;\n        }\n\n        // If not, see if we're allowed to delete recursively\n        if(!options.recursive) {\n          callback(new Errors.ENOTEMPTY(null, pathname));\n          return;\n        }\n\n        // Remove each dir entry recursively, then delete the dir.\n        entries = entries.map(function(filename) {\n          // Root dir entries absolutely\n          return Path.join(pathname, filename);\n        });\n        async.eachSeries(entries, remove, function(error) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          fs.rmdir(pathname, callback);\n        });\n      });\n    });\n  }\n\n  remove(path, callback);\n};\n\n/**\n * Gets the path to the temporary directory, creating it if not\n * present. The directory used is the one specified in\n * env.TMP. The callback receives (error, tempDirName).\n */\nShell.prototype.tempDir = function(callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var tmp = sh.env.get('TMP');\n  callback = callback || function(){};\n\n  // Try and create it, and it will either work or fail\n  // but either way it's now there.\n  fs.mkdir(tmp, function() {\n    callback(null, tmp);\n  });\n};\n\n/**\n * Recursively creates the directory at `path`. If the parent\n * of `path` does not exist, it will be created.\n * Based off EnsureDir by Sam X. Xu\n * https://www.npmjs.org/package/ensureDir\n * MIT License\n */\nShell.prototype.mkdirp = function(path, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n  path = Path.resolve(sh.pwd(), path);\n  if (path === '/') {\n    callback();\n    return;\n  }\n  function _mkdirp(path, callback) {\n    fs.stat(path, function (err, stat) {\n      if(stat) {\n        if(stat.isDirectory()) {\n          callback();\n          return;\n        }\n        else if (stat.isFile()) {\n          callback(new Errors.ENOTDIR(null, path));\n          return;\n        }\n      }\n      else if (err && err.code !== 'ENOENT') {\n        callback(err);\n        return;\n      }\n      else {\n        var parent = Path.dirname(path);\n        if(parent === '/') {\n          fs.mkdir(path, function (err) {\n            if (err && err.code !== 'EEXIST') {\n              callback(err);\n              return;\n            }\n            callback();\n            return;\n          });\n        }\n        else {\n          _mkdirp(parent, function (err) {\n            if (err) return callback(err);\n            fs.mkdir(path, function (err) {\n              if (err && err.code !== 'EEXIST') {\n                callback(err);\n                return;\n              }\n              callback();\n              return;\n            });\n          });\n        }\n      }\n    });\n  }\n\n  _mkdirp(path, callback);\n};\n\n/**\n * Recursively walk a directory tree, reporting back all paths\n * that were found along the way. The `path` must be a dir.\n * Valid options include a `regex` for pattern matching paths\n * and an `exec` function of the form `function(path, next)` where\n * `path` is the current path that was found (dir paths have an '/'\n * appended) and `next` is a callback to call when done processing\n * the current path, passing any error object back as the first argument.\n * `find` returns a flat array of absolute paths for all matching/found\n * paths as the final argument to the callback.\n */\nShell.prototype.find = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  var exec = options.exec || function(path, next) { next(); };\n  var found = [];\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function processPath(path, callback) {\n    exec(path, function(err) {\n      if(err) {\n        callback(err);\n        return;\n      }\n\n      found.push(path);\n      callback();\n    });\n  }\n\n  function maybeProcessPath(path, callback) {\n    // Test the path against the user's regex, name, path primaries (if any)\n    // and remove any trailing slashes added previously.\n    var rawPath = Path.removeTrailing(path);\n\n    // Check entire path against provided regex, if any\n    if(options.regex && !options.regex.test(rawPath)) {\n      callback();\n      return;\n    }\n\n    // Check basename for matches against name primary, if any\n    if(options.name && !minimatch(Path.basename(rawPath), options.name)) {\n      callback();\n      return;\n    }\n\n    // Check dirname for matches against path primary, if any\n    if(options.path && !minimatch(Path.dirname(rawPath), options.path)) {\n      callback();\n      return;\n    }\n\n    processPath(path, callback);\n  }\n\n  function walk(path, callback) {\n    path = Path.resolve(sh.pwd(), path);\n\n    // The path is either a file or dir, and instead of doing\n    // a stat() to determine it first, we just try to readdir()\n    // and it will either work or not, and we handle the non-dir error.\n    fs.readdir(path, function(err, entries) {\n      if(err) {\n        if(err.code === 'ENOTDIR' /* file case, ignore error */) {\n          maybeProcessPath(path, callback);\n        } else {\n          callback(err);\n        }\n        return;\n      }\n\n      // Path is really a dir, add a trailing / and report it found\n      maybeProcessPath(Path.addTrailing(path), function(err) {\n        if(err) {\n          callback(err);\n          return;\n        }\n\n        entries = entries.map(function(entry) {\n          return Path.join(path, entry);\n        });\n\n        async.eachSeries(entries, walk, function(err) {\n          callback(err, found);\n        });\n      });\n    });\n  }\n\n  // Make sure we are starting with a dir path\n  fs.stat(path, function(err, stats) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    if(!stats.isDirectory()) {\n      callback(new Errors.ENOTDIR(null, path));\n      return;\n    }\n\n    walk(path, callback);\n  });\n};\n\nmodule.exports = Shell;\n", "// Based on https://github.com/diy/intercom.js/blob/master/lib/events.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nfunction removeItem(item, array) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array;\n}\n\nvar EventEmitter = function() {};\n\nEventEmitter.createInterface = function(space) {\n  var methods = {};\n\n  methods.on = function(name, fn) {\n    if (typeof this[space] === 'undefined') {\n      this[space] = {};\n    }\n    if (!this[space].hasOwnProperty(name)) {\n      this[space][name] = [];\n    }\n    this[space][name].push(fn);\n  };\n\n  methods.off = function(name, fn) {\n    if (typeof this[space] === 'undefined') return;\n    if (this[space].hasOwnProperty(name)) {\n      removeItem(fn, this[space][name]);\n    }\n  };\n\n  methods.trigger = function(name) {\n    if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      for (var i = 0; i < this[space][name].length; i++) {\n        this[space][name][i].apply(this[space][name][i], args);\n      }\n    }\n  };\n\n  methods.removeAllListeners = function(name) {\n    if (typeof this[space] === 'undefined') return;\n    var self = this;\n    self[space][name].forEach(function(fn) {\n      self.off(name, fn);\n    });\n  };\n\n  return methods;\n};\n\nvar pvt = EventEmitter.createInterface('_handlers');\nEventEmitter.prototype._on = pvt.on;\nEventEmitter.prototype._off = pvt.off;\nEventEmitter.prototype._trigger = pvt.trigger;\n\nvar pub = EventEmitter.createInterface('handlers');\nEventEmitter.prototype.on = function() {\n  pub.on.apply(this, arguments);\n  Array.prototype.unshift.call(arguments, 'on');\n  this._trigger.apply(this, arguments);\n};\nEventEmitter.prototype.off = pub.off;\nEventEmitter.prototype.trigger = pub.trigger;\nEventEmitter.prototype.removeAllListeners = pub.removeAllListeners;\n\nmodule.exports = EventEmitter;\n", "function generateRandom(template) {\n  return template.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n}\n\nfunction guid() {\n  return generateRandom('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').toUpperCase();\n}\n\n/**\n * Generate a string of n random characters.  Defaults to n=6.\n */ \nfunction randomChars(n) {\n  n = n || 6;\n  var template = 'x'.repeat(n);\n  return generateRandom(template);\n}\n\nfunction nop() {}\n\nmodule.exports = {\n  guid: guid,\n  nop: nop,\n  randomChars: randomChars\n};\n", "// Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nvar EventEmitter = require('./eventemitter.js');\nvar guid = require('../src/shared.js').guid;\n\nfunction throttle(delay, fn) {\n  var last = 0;\n  return function() {\n    var now = Date.now();\n    if (now - last > delay) {\n      last = now;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nfunction extend(a, b) {\n  if (typeof a === 'undefined' || !a) { a = {}; }\n  if (typeof b === 'object') {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n}\n\nvar localStorage = (function(window) {\n  if (typeof window === 'undefined' ||\n      typeof window.localStorage === 'undefined') {\n    return {\n      getItem : function() {},\n      setItem : function() {},\n      removeItem : function() {}\n    };\n  }\n  return window.localStorage;\n}(global));\n\nfunction Intercom() {\n  var self = this;\n  var now = Date.now();\n\n  this.origin         = guid();\n  this.lastMessage    = now;\n  this.receivedIDs    = {};\n  this.previousValues = {};\n\n  var storageHandler = function() {\n    self._onStorageEvent.apply(self, arguments);\n  };\n\n  // If we're in node.js, skip event registration\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (document.attachEvent) {\n    document.attachEvent('onstorage', storageHandler);\n  } else {\n    global.addEventListener('storage', storageHandler, false);\n  }\n}\n\nIntercom.prototype._transaction = function(fn) {\n  var TIMEOUT   = 1000;\n  var WAIT      = 20;\n  var self      = this;\n  var executed  = false;\n  var listening = false;\n  var waitTimer = null;\n\n  function lock() {\n    if (executed) {\n      return;\n    }\n\n    var now = Date.now();\n    var activeLock = localStorage.getItem(INDEX_LOCK)|0;\n    if (activeLock && now - activeLock < TIMEOUT) {\n      if (!listening) {\n        self._on('storage', lock);\n        listening = true;\n      }\n      waitTimer = setTimeout(lock, WAIT);\n      return;\n    }\n    executed = true;\n    localStorage.setItem(INDEX_LOCK, now);\n\n    fn();\n    unlock();\n  }\n\n  function unlock() {\n    if (listening) {\n      self._off('storage', lock);\n    }\n    if (waitTimer) {\n      clearTimeout(waitTimer);\n    }\n    localStorage.removeItem(INDEX_LOCK);\n  }\n\n  lock();\n};\n\nIntercom.prototype._cleanup_emit = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var now = Date.now();\n    var threshold = now - THRESHOLD_TTL_EMIT;\n    var changed = 0;\n    var messages;\n\n    try {\n      messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');\n    } catch(e) {\n      messages = [];\n    }\n    for (var i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].timestamp < threshold) {\n        messages.splice(i, 1);\n        changed++;\n      }\n    }\n    if (changed > 0) {\n      localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));\n    }\n  });\n});\n\nIntercom.prototype._cleanup_once = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var timestamp, ttl, key;\n    var table;\n    var now  = Date.now();\n    var changed = 0;\n\n    try {\n      table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      table = {};\n    }\n    for (key in table) {\n      if (self._once_expired(key, table)) {\n        delete table[key];\n        changed++;\n      }\n    }\n\n    if (changed > 0) {\n      localStorage.setItem(INDEX_ONCE, JSON.stringify(table));\n    }\n  });\n});\n\nIntercom.prototype._once_expired = function(key, table) {\n  if (!table) {\n    return true;\n  }\n  if (!table.hasOwnProperty(key)) {\n    return true;\n  }\n  if (typeof table[key] !== 'object') {\n    return true;\n  }\n\n  var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;\n  var now = Date.now();\n  var timestamp = table[key].timestamp;\n  return timestamp < now - ttl;\n};\n\nIntercom.prototype._localStorageChanged = function(event, field) {\n  if (event && event.key) {\n    return event.key === field;\n  }\n\n  var currentValue = localStorage.getItem(field);\n  if (currentValue === this.previousValues[field]) {\n    return false;\n  }\n  this.previousValues[field] = currentValue;\n  return true;\n};\n\nIntercom.prototype._onStorageEvent = function(event) {\n  event = event || global.event;\n  var self = this;\n\n  if (this._localStorageChanged(event, INDEX_EMIT)) {\n    this._transaction(function() {\n      var now = Date.now();\n      var data = localStorage.getItem(INDEX_EMIT);\n      var messages;\n\n      try {\n        messages = JSON.parse(data || '[]');\n      } catch(e) {\n        messages = [];\n      }\n      for (var i = 0; i < messages.length; i++) {\n        if (messages[i].origin === self.origin) continue;\n        if (messages[i].timestamp < self.lastMessage) continue;\n        if (messages[i].id) {\n          if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;\n          self.receivedIDs[messages[i].id] = true;\n        }\n        self.trigger(messages[i].name, messages[i].payload);\n      }\n      self.lastMessage = now;\n    });\n  }\n\n  this._trigger('storage', event);\n};\n\nIntercom.prototype._emit = function(name, message, id) {\n  id = (typeof id === 'string' || typeof id === 'number') ? String(id) : null;\n  if (id && id.length) {\n    if (this.receivedIDs.hasOwnProperty(id)) return;\n    this.receivedIDs[id] = true;\n  }\n\n  var packet = {\n    id        : id,\n    name      : name,\n    origin    : this.origin,\n    timestamp : Date.now(),\n    payload   : message\n  };\n\n  var self = this;\n  this._transaction(function() {\n    var data = localStorage.getItem(INDEX_EMIT) || '[]';\n    var delimiter = (data === '[]') ? '' : ',';\n    data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');\n    localStorage.setItem(INDEX_EMIT, data);\n    self.trigger(name, message);\n\n    setTimeout(function() {\n      self._cleanup_emit();\n    }, 50);\n  });\n};\n\nIntercom.prototype.emit = function(name, message) {\n  this._emit.apply(this, arguments);\n  this._trigger('emit', name, message);\n};\n\nIntercom.prototype.once = function(key, fn, ttl) {\n  if (!Intercom.supported) {\n    return;\n  }\n\n  var self = this;\n  this._transaction(function() {\n    var data;\n    try {\n      data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      data = {};\n    }\n    if (!self._once_expired(key, data)) {\n      return;\n    }\n\n    data[key] = {};\n    data[key].timestamp = Date.now();\n    if (typeof ttl === 'number') {\n      data[key].ttl = ttl * 1000;\n    }\n\n    localStorage.setItem(INDEX_ONCE, JSON.stringify(data));\n    fn();\n\n    setTimeout(function() {\n      self._cleanup_once();\n    }, 50);\n  });\n};\n\nextend(Intercom.prototype, EventEmitter.prototype);\n\nIntercom.supported = (typeof localStorage !== 'undefined');\n\nvar INDEX_EMIT = 'intercom';\nvar INDEX_ONCE = 'intercom_once';\nvar INDEX_LOCK = 'intercom_lock';\n\nvar THRESHOLD_TTL_EMIT = 50000;\nvar THRESHOLD_TTL_ONCE = 1000 * 3600;\n\nIntercom.destroy = function() {\n  localStorage.removeItem(INDEX_LOCK);\n  localStorage.removeItem(INDEX_EMIT);\n  localStorage.removeItem(INDEX_ONCE);\n};\n\nIntercom.getInstance = (function() {\n  var intercom;\n  return function() {\n    if (!intercom) {\n      intercom = new Intercom();\n    }\n    return intercom;\n  };\n})();\n\nmodule.exports = Intercom;\n", "'using strict';\n\nconst EventEmitter = require('../lib/eventemitter.js');\nconst Path = require('./path.js');\nconst Intercom = require('../lib/intercom.js');\n\n/**\n * FSWatcher based on node.js' FSWatcher\n * see https://github.com/joyent/node/blob/master/lib/fs.js\n */\nfunction FSWatcher() {\n  EventEmitter.call(this);\n  const self = this;\n  let recursive = false;\n  let recursivePathPrefix;\n  let filename;\n\n  function onchange(path) {\n    // Watch for exact filename, or parent path when recursive is true.\n    if(filename === path || (recursive && path.indexOf(recursivePathPrefix) === 0)) {\n      self.trigger('change', 'change', path);\n    }\n  }\n\n  // We support, but ignore the second arg, which node.js uses.\n  self.start = function(filename_, persistent_, recursive_) {\n    // Bail if we've already started (and therefore have a filename);\n    if(filename) {\n      return;\n    }\n\n    if(Path.isNull(filename_)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n\n    // TODO: get realpath for symlinks on filename...\n\n    // Filer's Path.normalize strips trailing slashes, which we use here.\n    // See https://github.com/js-platform/filer/issues/105\n    filename = Path.normalize(filename_);\n\n    // Whether to watch beneath this path or not\n    recursive = recursive_ === true;\n    // If recursive, construct a path prefix portion for comparisons later\n    // (i.e., '/path' becomes '/path/' so we can search within a filename for the\n    // prefix). We also take care to allow for '/' on its own.\n    if(recursive) {\n      recursivePathPrefix = filename === '/' ? '/' : filename + '/';\n    }\n\n    const intercom = Intercom.getInstance();\n    intercom.on('change', onchange);\n  };\n\n  self.close = function() {\n    const intercom = Intercom.getInstance();\n    intercom.off('change', onchange);\n    self.removeAllListeners('change');\n  };\n}\nFSWatcher.prototype = new EventEmitter();\nFSWatcher.prototype.constructor = FSWatcher;\n\nmodule.exports = FSWatcher;\n", "var NODE_TYPE_FILE = require('./constants.js').NODE_TYPE_FILE;\n\nmodule.exports = function DirectoryEntry(id, type) {\n  this.id = id;\n  this.type = type || NODE_TYPE_FILE;\n};\n", "const { FIRST_DESCRIPTOR } = require('./constants');\nconst openFiles = {};\n\n/**\n * Start at FIRST_DESCRIPTOR and go until we find\n * an empty file descriptor, then return it.\n */\nconst getEmptyDescriptor = () => {\n  let fd = FIRST_DESCRIPTOR;\n\n  while(getOpenFileDescription(fd)) {\n    fd++;\n  }\n\n  return fd;\n};\n\n/**\n * Look up the open file description object for a given\n * file descriptor.\n */\nconst getOpenFileDescription = ofd => openFiles[ofd];\n\n/**\n * Allocate a new file descriptor for the given\n * open file description. \n */\nconst allocDescriptor = openFileDescription => {\n  const ofd = getEmptyDescriptor();\n  openFiles[ofd] = openFileDescription;\n  return ofd;\n};\n\n/**\n * Release the given existing file descriptor created\n * with allocDescriptor(). \n */\nconst releaseDescriptor = ofd => delete openFiles[ofd];\n\nmodule.exports = {\n  allocDescriptor,\n  releaseDescriptor,\n  getOpenFileDescription\n};\n", "const {\n  NODE_TYPE_FILE,\n  NODE_TYPE_DIRECTORY,\n  NODE_TYPE_SYMBOLIC_LINK,\n  DEFAULT_FILE_PERMISSIONS,\n  DEFAULT_DIR_PERMISSIONS\n} = require('./constants');\nconst {\n  S_IFREG,\n  S_IFDIR,\n  S_IFLNK\n} = require('./constants').fsConstants;\n\n/**\n * Make sure the options object has an id on property,\n * either from caller or one we generate using supplied guid fn.\n */\nfunction ensureID(options, prop, callback) {\n  if(options[prop]) {\n    return callback();\n  }\n\n  options.guid(function(err, id) {\n    if(err) {\n      return callback(err);\n    }\n    options[prop] = id;\n    callback();\n  });\n}\n\n/**\n * Generate a POSIX mode (integer) for the node type and permissions.\n * Use default permissions if we aren't passed any.\n */\nfunction generateMode(nodeType, modePermissions) {\n  switch(nodeType) {\n  case NODE_TYPE_DIRECTORY:\n    return (modePermissions || DEFAULT_DIR_PERMISSIONS) | S_IFDIR;\n  case NODE_TYPE_SYMBOLIC_LINK:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFLNK;\n  case NODE_TYPE_FILE:\n    // falls through\n  default:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFREG;\n  }\n}\n\n/**\n * Common properties for the layout of a Node\n */\nclass Node {\n  constructor(options) {\n    var now = Date.now();\n\n    this.id = options.id;\n    this.data = options.data; // id for data object\n    this.size = options.size || 0; // size (bytes for files, entries for directories)\n    this.atime = options.atime || now; // access time (will mirror ctime after creation)\n    this.ctime = options.ctime || now; // creation/change time\n    this.mtime = options.mtime || now; // modified time\n    this.flags = options.flags || []; // file flags\n    this.xattrs = options.xattrs || {}; // extended attributes\n    this.nlinks = options.nlinks || 0; // links count\n\n    // Historically, Filer's node layout has referred to the\n    // node type as `mode`, and done so using a String.  In\n    // a POSIX filesystem, the mode is a number that combines\n    // both node type and permission bits. Internal we use `type`,\n    // but store it in the database as `mode` for backward\n    // compatibility.\n    if(typeof options.type === 'string') {\n      this.type = options.type;\n    } else if(typeof options.mode === 'string') {\n      this.type = options.mode;\n    } else {\n      this.type = NODE_TYPE_FILE;\n    }\n\n    // Extra mode permissions and ownership info\n    this.permissions = options.permissions || generateMode(this.type);\n    this.uid = options.uid || 0x0; // owner name\n    this.gid = options.gid || 0x0; // group name\n  }\n\n  /**\n   * Serialize a Node to JSON.  Everything is as expected except\n   * that we use `mode` for `type` to maintain backward compatibility.\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      data: this.data,\n      size: this.size,\n      atime: this.atime,\n      ctime: this.ctime,\n      mtime: this.ctime,\n      flags: this.flags,\n      xattrs: this.xattrs,\n      nlinks: this.nlinks,\n      // Use `mode` for `type` to keep backward compatibility\n      mode: this.type,\n      permissions: this.permissions,\n      uid: this.uid,\n      gid: this.gid\n    };\n  }\n\n  // Return complete POSIX `mode` for node type + permissions. See:\n  // http://man7.org/linux/man-pages/man2/chmod.2.html\n  get mode() {\n    return generateMode(this.type, this.permissions);\n  }\n  // When setting the `mode` we assume permissions bits only (not changing type)\n  set mode(value) {\n    this.permissions = value;\n  }\n}\n\nmodule.exports.create = function create(options, callback) {\n  // We expect both options.id and options.data to be provided/generated.\n  ensureID(options, 'id', function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    ensureID(options, 'data', function(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      callback(null, new Node(options));\n    });\n  });\n};\n", "const Errors = require('./errors.js');\nconst Node = require('./node');\n\nfunction OpenFileDescription(path, id, flags, position) {\n  this.path = path;\n  this.id = id;\n  this.flags = flags;\n  this.position = position;\n}\n\n// Tries to find the node associated with an ofd's `id`.\n// If not found, an error is returned on the callback.\nOpenFileDescription.prototype.getNode = function(context, callback) {\n  var id = this.id;\n  var path = this.path;\n\n  function check_if_node_exists(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    if(!node) {\n      return callback(new Errors.EBADF('file descriptor refers to unknown node', path));\n    }\n\n    Node.create(node, callback);\n  }\n\n  context.getObject(id, check_if_node_exists);\n};\n\nmodule.exports = OpenFileDescription;\n", "var Constants = require('./constants.js');\n\nfunction SuperNode(options) {\n  var now = Date.now();\n\n  this.id = Constants.SUPER_NODE_ID;\n  this.type = Constants.NODE_TYPE_META;\n  this.atime = options.atime || now;\n  this.ctime = options.ctime || now;\n  this.mtime = options.mtime || now;\n  // root node id (randomly generated)\n  this.rnode = options.rnode;\n}\n\nSuperNode.create = function(options, callback) {\n  options.guid(function(err, rnode) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    options.rnode = options.rnode || rnode;\n    callback(null, new SuperNode(options));\n  });\n};\n\nmodule.exports = SuperNode;\n", "'use strict';\n\nconst Constants = require('./constants.js');\nconst Path = require('./path.js');\n\nfunction dateFromMs(ms) {\n  return new Date(Number(ms));\n}\n\nfunction Stats(path, fileNode, devName) {\n  this.dev = devName;\n  this.node = fileNode.id;\n  this.type = fileNode.type;\n  this.size = fileNode.size;\n  this.nlinks = fileNode.nlinks;\n  // Date objects\n  this.atime = dateFromMs(fileNode.atime);\n  this.mtime = dateFromMs(fileNode.mtime);\n  this.ctime = dateFromMs(fileNode.ctime);\n  // Unix timestamp MS Numbers\n  this.atimeMs = fileNode.atime;\n  this.mtimeMs = fileNode.mtime;\n  this.ctimeMs = fileNode.ctime;\n  this.version = fileNode.version;\n  this.mode = fileNode.mode;\n  this.uid = fileNode.uid;\n  this.gid = fileNode.gid;\n  this.name = Path.basename(path);\n}\n\nStats.prototype.isFile = function() {\n  return this.type === Constants.NODE_TYPE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n  return this.type === Constants.NODE_TYPE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this.type === Constants.NODE_TYPE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\nStats.prototype.isFIFO            =\nStats.prototype.isCharacterDevice =\nStats.prototype.isBlockDevice     =\nfunction() {\n  return false;\n};\n\nmodule.exports = Stats;\n", "'use strict';\n\nconst Stats = require('./stats.js');\n\nfunction Dirent(path, fileNode, devName) {\n  this.constructor = Dirent;\n  Stats.call(this, path, fileNode, devName);\n}\n\nDirent.prototype = Stats.prototype;\n\nmodule.exports = Dirent;\n", "var Path = require('../path.js');\nvar normalize = Path.normalize;\nvar dirname = Path.dirname;\nvar basename = Path.basename;\nvar isAbsolutePath = Path.isAbsolute;\nvar shared = require('../shared.js');\nvar async = require('../../lib/async.js');\n\nvar Constants = require('../constants.js');\nvar NODE_TYPE_FILE = Constants.NODE_TYPE_FILE;\nvar NODE_TYPE_DIRECTORY = Constants.NODE_TYPE_DIRECTORY;\nvar NODE_TYPE_SYMBOLIC_LINK = Constants.NODE_TYPE_SYMBOLIC_LINK;\nvar NODE_TYPE_META = Constants.NODE_TYPE_META;\n\nvar FULL_READ_WRITE_EXEC_PERMISSIONS = Constants.FULL_READ_WRITE_EXEC_PERMISSIONS;\n\nvar ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;\nvar SUPER_NODE_ID = Constants.SUPER_NODE_ID;\nvar SYMLOOP_MAX = Constants.SYMLOOP_MAX;\n\nvar O_READ = Constants.O_READ;\nvar O_WRITE = Constants.O_WRITE;\nvar O_CREATE = Constants.O_CREATE;\nvar O_EXCLUSIVE = Constants.O_EXCLUSIVE;\nvar O_APPEND = Constants.O_APPEND;\nvar O_FLAGS = Constants.O_FLAGS;\n\nvar XATTR_CREATE = Constants.XATTR_CREATE;\nvar XATTR_REPLACE = Constants.XATTR_REPLACE;\nvar FS_NOMTIME = Constants.FS_NOMTIME;\nvar FS_NOCTIME = Constants.FS_NOCTIME;\n\nvar Errors = require('../errors.js');\nvar DirectoryEntry = require('../directory-entry.js');\nvar openFiles = require('../open-files.js');\nvar OpenFileDescription = require('../open-file-description.js');\nvar SuperNode = require('../super-node.js');\nvar Node = require('../node.js');\nvar Dirent = require('../dirent.js');\nvar Stats = require('../stats.js');\n\n/**\n * Update node times. Only passed times are modified (undefined times are ignored)\n * and filesystem flags are examined in order to override update logic.\n */\nfunction update_node_times(context, path, node, times, callback) {\n  // Honour mount flags for how we update times\n  var flags = context.flags;\n  if(flags.includes(FS_NOCTIME)) {\n    delete times.ctime;\n  }\n  if(flags.includes(FS_NOMTIME)) {\n    delete times.mtime;\n  }\n\n  // Only do the update if required (i.e., times are still present)\n  var update = false;\n  if(times.ctime) {\n    node.ctime = times.ctime;\n    // We don't do atime tracking for perf reasons, but do mirror ctime\n    node.atime = times.ctime;\n    update = true;\n  }\n  if(times.atime) {\n    // The only time we explicitly pass atime is when utimes(), futimes() is called.\n    // Override ctime mirror here if so\n    node.atime = times.atime;\n    update = true;\n  }\n  if(times.mtime) {\n    node.mtime = times.mtime;\n    update = true;\n  }\n\n  function complete(error) {\n    // Queue this change so we can send watch events.\n    // Unlike node.js, we send the full path vs. basename/dirname only.\n    context.changes.push({ event: 'change', path: path });\n    callback(error);\n  }\n\n  if(update) {\n    context.putObject(node.id, node, complete);\n  } else {\n    complete();\n  }\n}\n\n/**\n * make_node()\n */\n// in: file or directory path\n// out: new node representing file/directory\nfunction make_node(context, path, type, callback) {\n  if(type !== NODE_TYPE_DIRECTORY && type !== NODE_TYPE_FILE) {\n    return callback(new Errors.EINVAL('type must be a directory or file', path));\n  }\n\n  path = normalize(path);\n\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var parentNode;\n  var parentNodeData;\n  var node;\n\n  // Check if the parent node exists\n  function create_node_in_parent(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      parentNode = parentDirectoryNode;\n      find_node(context, path, check_if_node_exists);\n    }\n  }\n\n  // Check if the node to be created already exists\n  function check_if_node_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST('path name already exists', path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      context.getObject(parentNode.data, create_node);\n    }\n  }\n\n  // Create the new node\n  function create_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData = result;\n      Node.create({\n        guid: context.guid,\n        type: type\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        node = result;\n        node.nlinks += 1;\n        context.putObject(node.id, node, update_parent_node_data);\n      });\n    }\n  }\n\n  // Update parent node time\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, node, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  // Update the parent nodes data\n  function update_parent_node_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData[name] = new DirectoryEntry(node.id, type);\n      context.putObject(parentNode.data, parentNodeData, update_time);\n    }\n  }\n\n  // Find the parent node\n  find_node(context, parentPath, create_node_in_parent);\n}\n\n/**\n * find_node\n */\n// in: file or directory path\n// out: node structure, or error\nfunction find_node(context, path, callback) {\n  path = normalize(path);\n  if(!path) {\n    return callback(new Errors.ENOENT('path is an empty string'));\n  }\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var followedCount = 0;\n\n  function read_root_directory_node(error, nodeData) {\n    if(error) {\n      return callback(error);\n    }\n\n    // Parse existing node as SuperNode\n    const superNode = new SuperNode(nodeData);\n\n    if(!superNode || superNode.type !== NODE_TYPE_META || !superNode.rnode) {\n      callback(new Errors.EFILESYSTEMERROR());\n    } else {\n      context.getObject(superNode.rnode, check_root_directory_node);\n    }\n  }\n\n  function check_root_directory_node(error, rootDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(!rootDirectoryNode) {\n      callback(new Errors.ENOENT());\n    } else {\n      Node.create(rootDirectoryNode, callback);\n    }\n  }\n\n  // in: parent directory node\n  // out: parent directory data\n  function read_parent_directory_data(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY || !parentDirectoryNode.data) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);\n    }\n  }\n\n  // in: parent directory data\n  // out: searched node\n  function get_node_from_parent_directory_data(error, parentDirectoryData) {\n    if(error) {\n      callback(error);\n    } else {\n      if(!Object.prototype.hasOwnProperty.call(parentDirectoryData, name)) {\n        callback(new Errors.ENOENT(null, path));\n      } else {\n        var nodeId = parentDirectoryData[name].id;\n        context.getObject(nodeId, create_node);\n      }\n    }\n  }\n\n  function create_node(error, data) {\n    if(error) {\n      return callback(error);\n    }\n    Node.create(data, is_symbolic_link);\n  }\n\n  function is_symbolic_link(error, node) {\n    if(error) {\n      callback(error);\n    } else {\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        callback(null, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      context.getObject(SUPER_NODE_ID, read_root_directory_node);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    context.getObject(SUPER_NODE_ID, read_root_directory_node);\n  } else {\n    find_node(context, parentPath, read_parent_directory_data);\n  }\n}\n\n\n/**\n * set extended attribute (refactor)\n */\nfunction set_extended_attribute (context, path, node, name, value, flag, callback) {\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { ctime: Date.now() }, callback);\n    }\n  }\n\n  var xattrs = node.xattrs;\n\n  if (flag === XATTR_CREATE && Object.prototype.hasOwnProperty.call(xattrs, name)) {\n    callback(new Errors.EEXIST('attribute already exists', path));\n  }\n  else if (flag === XATTR_REPLACE && !Object.prototype.hasOwnProperty.call(xattrs, name)) {\n    callback(new Errors.ENOATTR(null, path));\n  }\n  else {\n    xattrs[name] = value;\n    context.putObject(node.id, node, update_time);\n  }\n}\n\n/**\n * ensure_root_directory. Creates a root node if necessary.\n *\n * Note: this should only be invoked when formatting a new file system.\n * Multiple invocations of this by separate instances will still result\n * in only a single super node.\n */\nfunction ensure_root_directory(context, callback) {\n  var superNode;\n  var directoryNode;\n  var directoryData;\n\n  function ensure_super_node(error, existingNode) {\n    if(!error && existingNode) {\n      // Another instance has beat us and already created the super node.\n      callback();\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      SuperNode.create({guid: context.guid}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        superNode = result;\n        context.putObject(superNode.id, superNode, write_directory_node);\n      });\n    }\n  }\n\n  function write_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      Node.create({\n        guid: context.guid,\n        id: superNode.rnode,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, callback);\n    }\n  }\n\n  context.getObject(SUPER_NODE_ID, ensure_super_node);\n}\n\n/**\n * make_directory\n */\nfunction make_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function check_if_directory_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST(null, path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, write_directory_node);\n    }\n  }\n\n  function write_directory_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData = result;\n      Node.create({\n        guid: context.guid,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, update_parent_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, NODE_TYPE_DIRECTORY);\n      context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n    }\n  }\n\n  find_node(context, path, check_if_directory_exists);\n}\n\nfunction access_file(context, path, mode, callback) {\n  const { F_OK, R_OK, W_OK, X_OK, S_IXUSR, S_IXGRP, S_IXOTH } = Constants.fsConstants;\n\n  path = normalize(path);\n  find_node(context, path, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    // If we have a node, F_OK is true.\n    if(mode === F_OK) {\n      return callback(null);\n    }\n\n    var st_mode = validateAndMaskMode(node.mode, callback);\n    if(!st_mode) return;\n\n    // For any other combo of F_OK, R_OK, W_OK, always allow. Filer user is a root user,\n    // so existing files are always OK, readable, and writable\n    if(mode & (R_OK | W_OK)) {\n      return callback(null);\n    }\n\n    // For the case of X_OK, actually check if this file is executable\n    if ((mode & X_OK) && (st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n      return callback(null);\n    }\n\n    // In any other case, the file isn't accessible\n    callback(new Errors.EACCES('permission denied',path)) ;\n  });\n}\n\n/**\n * remove_directory\n */\nfunction remove_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, check_if_node_exists);\n    }\n  }\n\n  function check_if_node_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else if(ROOT_DIRECTORY_NAME === name) {\n      callback(new Errors.EBUSY(null, path));\n    } else if(!Object.prototype.hasOwnProperty.call(result, name)) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      parentDirectoryData = result;\n      directoryNode = parentDirectoryData[name].id;\n      context.getObject(directoryNode, check_if_node_is_directory);\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_directory_is_empty);\n    }\n  }\n\n  function check_if_directory_is_empty(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(Object.keys(directoryData).length > 0) {\n        callback(new Errors.ENOTEMPTY(null, path));\n      } else {\n        remove_directory_entry_from_parent_directory_node();\n      }\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, remove_directory_node);\n    }\n  }\n\n  function remove_directory_entry_from_parent_directory_node() {\n    delete parentDirectoryData[name];\n    context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n  }\n\n  function remove_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.id, remove_directory_data);\n    }\n  }\n\n  function remove_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.data, callback);\n    }\n  }\n\n  find_node(context, parentPath, read_parent_directory_data);\n}\n\nfunction open_file(context, path, flags, mode, callback) {\n  if (typeof mode === 'function'){\n    callback = mode;\n    mode = null;\n  }\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var directoryEntry;\n  var fileNode;\n  var fileData;\n\n  var followedCount = 0;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    if(flags.includes(O_WRITE)) {\n      callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n    } else {\n      find_node(context, path, set_file_node);\n    }\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(Object.prototype.hasOwnProperty.call(directoryData, name)) {\n        if(flags.includes(O_EXCLUSIVE)) {\n          callback(new Errors.EEXIST('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));\n        } else {\n          directoryEntry = directoryData[name];\n          if(directoryEntry.type === NODE_TYPE_DIRECTORY && flags.includes(O_WRITE)) {\n            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n          } else {\n            context.getObject(directoryEntry.id, check_if_symbolic_link);\n          }\n        }\n      } else {\n        if(!flags.includes(O_CREATE)) {\n          callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));\n        } else {\n          write_file_node();\n        }\n      }\n    }\n  }\n\n  function check_if_symbolic_link(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var node = result;\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        set_file_node(undefined, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      if(flags.includes(O_WRITE)) {\n        callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n      } else {\n        find_node(context, path, set_file_node);\n      }\n    }\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function set_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      callback(null, fileNode);\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_FILE\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      if(mode){\n        fileNode.mode = mode;\n      }\n      context.putObject(fileNode.id, fileNode, write_file_data);\n    });\n  }\n\n  function write_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = Buffer.alloc(0);\n      context.putBuffer(fileNode.data, fileData, update_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, handle_update_result);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_FILE);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n\n  function handle_update_result(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, fileNode);\n    }\n  }\n}\n\nfunction replace_data(context, ofd, buffer, offset, length, callback) {\n  var fileNode;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function write_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n\n      var newData = Buffer.alloc(length);\n      buffer.copy(newData, 0, offset, offset + length);\n      ofd.position = length;\n\n      fileNode.size = length;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  context.getObject(ofd.id, write_file_data);\n}\n\nfunction write_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function update_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      var newSize = Math.max(fileData.length, _position + length);\n      var newData = Buffer.alloc(newSize);\n      if(fileData) {\n        fileData.copy(newData);\n      }\n      buffer.copy(newData, _position, offset, offset + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n\n      fileNode.size = newSize;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, update_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction read_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function handle_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      length = (_position + length > buffer.length) ? length - _position : length;\n      fileData.copy(buffer, offset, _position, _position + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n      callback(null, length);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EISDIR('the named file is a directory', ofd.path));\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, handle_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction stat_file(context, path, callback) {\n  path = normalize(path);\n  find_node(context, path, callback);\n}\n\nfunction fstat_file(context, ofd, callback) {\n  ofd.getNode(context, callback);\n}\n\nfunction lstat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    find_node(context, path, callback);\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function create_node(error, data) {\n    if(error) {\n      return callback(error);\n    }\n    Node.create(data, callback);\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!Object.prototype.hasOwnProperty.call(directoryData, name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', path));\n      } else {\n        context.getObject(directoryData[name].id, create_node);\n      }\n    }\n  }\n}\n\nfunction link_node(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  var oldname = basename(oldpath);\n  var oldParentPath = dirname(oldpath);\n\n  newpath = normalize(newpath);\n  var newname = basename(newpath);\n  var newParentPath = dirname(newpath);\n  var ctime = Date.now();\n\n  var oldDirectoryNode;\n  var oldDirectoryData;\n  var newDirectoryNode;\n  var newDirectoryData;\n  var fileNodeID;\n  var fileNode;\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function read_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(fileNodeID, update_file_node);\n    }\n  }\n\n  function check_if_new_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryData = result;\n      if(Object.prototype.hasOwnProperty.call(newDirectoryData, newname)) {\n        callback(new Errors.EEXIST('newpath resolves to an existing file', newname));\n      } else {\n        newDirectoryData[newname] = oldDirectoryData[oldname];\n        fileNodeID = newDirectoryData[newname].id;\n        context.putObject(newDirectoryNode.data, newDirectoryData, read_file_node);\n      }\n    }\n  }\n\n  function read_new_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryNode = result;\n      context.getObject(newDirectoryNode.data, check_if_new_file_exists);\n    }\n  }\n\n  function check_if_old_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryData = result;\n      if(!Object.prototype.hasOwnProperty.call(oldDirectoryData, oldname)) {\n        callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));\n      } else if(oldDirectoryData[oldname].type === NODE_TYPE_DIRECTORY) {\n        callback(new Errors.EPERM('oldpath refers to a directory'));\n      } else {\n        find_node(context, newParentPath, read_new_directory_data);\n      }\n    }\n  }\n\n  function read_old_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryNode = result;\n      context.getObject(oldDirectoryNode.data, check_if_old_file_exists);\n    }\n  }\n\n  find_node(context, oldParentPath, read_old_directory_data);\n}\n\nfunction unlink_node(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      delete directoryData[name];\n      context.putObject(directoryNode.data, directoryData, function(error) {\n        if(error) {\n          callback(error);\n        } else {\n          var now = Date.now();\n          update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n        }\n      });\n    }\n  }\n\n  function delete_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(fileNode.data, update_directory_data);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks -= 1;\n      if(fileNode.nlinks < 1) {\n        context.delete(fileNode.id, delete_file_data);\n      } else {\n        context.putObject(fileNode.id, fileNode, function(error) {\n          if(error) {\n            callback(error);\n          } else {\n            update_node_times(context, path, fileNode, { ctime: Date.now() }, update_directory_data);\n          }\n        });\n      }\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EPERM('unlink not permitted on directories', name));\n    } else {\n      update_file_node(null, result);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!Object.prototype.hasOwnProperty.call(directoryData, name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_node_is_directory);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  find_node(context, parentPath, read_directory_data);\n}\n\nfunction read_directory(context, path, options, callback) {\n  path = normalize(path);\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = validate_directory_options(options);\n\n  var directoryNode;\n  var directoryData;\n\n  function handle_directory_data(error, result) {\n    if (error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      var files = Object.keys(directoryData);\n\n      if (options.encoding) {\n        var fileBuffers = files.map(function (file) {\n          return Buffer.from(file);\n        });\n\n        if (options.encoding === 'buffer') {\n          files = fileBuffers;\n        }\n        else {\n          files = fileBuffers.map(function (fileBuffer) {\n            return fileBuffer.toString(options.encoding);\n          });\n        }\n      }\n\n      if (options.withFileTypes) {\n        var dirEnts = [];\n\n        // eslint-disable-next-line no-inner-declarations\n        function to_dir_entry(file, callback) {\n          const filename = Buffer.from(file, options.encoding).toString();\n          const filepath = Path.join(path, filename);\n          get_dir_entry(context, filepath, function(error, dirEnt) {\n            if (error) {\n              callback(error);\n            }\n            dirEnt.name = file;\n            dirEnts.push(dirEnt);\n            callback();\n          });\n        }\n\n        async.eachSeries(files, to_dir_entry, function (error) {\n          callback(error, dirEnts);\n        });\n      }\n\n      else {\n        callback(null, files);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if (error) {\n      callback(error);\n    } else if (result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, handle_directory_data);\n    }\n  }\n\n  find_node(context, path, read_directory_data);\n}\n\nfunction get_dir_entry(context, path, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Dirent(path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction validate_directory_options(options, enc) {\n  if (!options) {\n    options = { encoding: enc };\n  } else if (typeof options === 'function') {\n    options = { encoding: enc };\n  } else if (typeof options === 'string') {\n    options = { encoding: options };\n  }\n  return options;\n}\n\nfunction make_symbolic_link(context, srcpath, dstpath, callback) {\n  dstpath = normalize(dstpath);\n  var name = basename(dstpath);\n  var parentPath = dirname(dstpath);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    callback(new Errors.EEXIST(null, name));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(Object.prototype.hasOwnProperty.call(directoryData, name)) {\n        callback(new Errors.EEXIST(null, name));\n      } else {\n        write_file_node();\n      }\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_SYMBOLIC_LINK\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n\n      // If the srcpath isn't absolute, resolve it relative to the dstpath\n      // but store both versions, since we'll use the relative one in readlink().\n      if(!isAbsolutePath(srcpath)) {\n        fileNode.symlink_relpath = srcpath;\n        srcpath = Path.resolve(parentPath, srcpath);\n      }\n\n      fileNode.size = srcpath.length;\n      fileNode.data = srcpath;\n\n      context.putObject(fileNode.id, fileNode, update_directory_data);\n    });\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_SYMBOLIC_LINK);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n}\n\nfunction read_link(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  find_node(context, parentPath, read_directory_data);\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!Object.prototype.hasOwnProperty.call(directoryData, name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_symbolic);\n      }\n    }\n  }\n\n  function check_if_symbolic(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      if(fileNode.type !== NODE_TYPE_SYMBOLIC_LINK) {\n        callback(new Errors.EINVAL('path not a symbolic link', path));\n      } else {\n        // If we were originally given a relative path, return that now vs. the\n        // absolute path we've generated and use elsewhere internally.\n        var target = fileNode.symlink_relpath ? fileNode.symlink_relpath : fileNode.data;\n        callback(null, target);\n      }\n    }\n  }\n}\n\nfunction truncate_file(context, path, length, callback) {\n  path = normalize(path);\n\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR(null, path));\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var data = Buffer.alloc(length);\n      if(fileData) {\n        fileData.copy(data);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    find_node(context, path, read_file_data);\n  }\n}\n\nfunction ftruncate_file(context, ofd, length, callback) {\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR());\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      var data;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      if(fileData) {\n        data = fileData.slice(0, length);\n      } else {\n        data = Buffer.alloc(length);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    ofd.getNode(context, read_file_data);\n  }\n}\n\nfunction utimes_file(context, path, atime, mtime, callback) {\n  path = normalize(path);\n\n  function update_times(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be number', path));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers', path));\n  }\n  else {\n    find_node(context, path, update_times);\n  }\n}\n\nfunction futimes_file(context, ofd, atime, mtime, callback) {\n\n  function update_times (error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, ofd.path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be a number'));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers'));\n  }\n  else {\n    ofd.getNode(context, update_times);\n  }\n}\n\nfunction setxattr_file(context, path, name, value, flag, callback) {\n  path = normalize(path);\n\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));\n  }\n  else {\n    find_node(context, path, setxattr);\n  }\n}\n\nfunction fsetxattr_file (context, ofd, name, value, flag, callback) {\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, ofd.path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));\n  }\n  else {\n    ofd.getNode(context, setxattr);\n  }\n}\n\nfunction getxattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function get_xattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, get_xattr);\n  }\n}\n\nfunction fgetxattr_file (context, ofd, name, callback) {\n\n  function get_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL());\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, get_xattr);\n  }\n}\n\nfunction removexattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, remove_xattr);\n  }\n}\n\nfunction fremovexattr_file (context, ofd, name, callback) {\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, ofd.path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, remove_xattr);\n  }\n}\n\nfunction validate_flags(flags) {\n  return Object.prototype.hasOwnProperty.call(O_FLAGS, flags) ? O_FLAGS[flags] : null;\n}\n\nfunction validate_file_options(options, enc, fileMode){\n  if(!options) {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'function') {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'string') {\n    options = { encoding: options, flag: fileMode };\n  }\n  return options;\n}\n\nfunction open(context, path, flags, mode, callback) {\n  if (arguments.length < 5 ){\n    callback = arguments[arguments.length - 1];\n    mode = 0o644;\n  }\n  else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n  }\n\n  function check_result(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      var position;\n      if(flags.includes(O_APPEND)) {\n        position = fileNode.size;\n      } else {\n        position = 0;\n      }\n      var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);\n      var fd = openFiles.allocDescriptor(openFileDescription);\n      callback(null, fd);\n    }\n  }\n\n  flags = validate_flags(flags);\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid'), path);\n  }\n\n  open_file(context, path, flags, mode, check_result);\n}\n\nfunction close(context, fd, callback) {\n  if(!openFiles.getOpenFileDescription(fd)) {\n    callback(new Errors.EBADF());\n  } else {\n    openFiles.releaseDescriptor(fd);\n    callback(null);\n  }\n}\n\nfunction mknod(context, path, type, callback) {\n  make_node(context, path, type, callback);\n}\n\nfunction mkdir(context, path, mode, callback) {\n  if (arguments.length < 4) {\n    callback = mode;\n    mode = FULL_READ_WRITE_EXEC_PERMISSIONS;\n  } else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n    if(!mode) return;\n  }\n\n  make_directory(context, path, callback);\n}\n\nfunction access(context, path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = Constants.fsConstants.F_OK;\n  }\n\n  mode = mode | Constants.fsConstants.F_OK;\n  access_file(context, path, mode, callback);\n}\n\nfunction mkdtemp(context, prefix, options, callback) {\n  callback = arguments[arguments.length - 1];\n  if(!prefix) {\n    return callback(new Error('filename prefix is required'));\n  }\n\n  let random = shared.randomChars(6);\n  var path = prefix + '-' + random;\n\n  make_directory(context, path, function(error) {\n    callback(error, path);\n  });\n}\n\nfunction rmdir(context, path, callback) {\n  remove_directory(context, path, callback);\n}\n\nfunction stat(context, path, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  stat_file(context, path, check_result);\n}\n\nfunction fstat(context, fd, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(ofd.path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    fstat_file(context, ofd, check_result);\n  }\n}\n\nfunction link(context, oldpath, newpath, callback) {\n  link_node(context, oldpath, newpath, callback);\n}\n\nfunction unlink(context, path, callback) {\n  unlink_node(context, path, callback);\n}\n\nfunction read(context, fd, buffer, offset, length, position, callback) {\n  // Follow how node.js does this\n  function wrapped_cb(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n  callback = arguments[arguments.length - 1];\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_READ)) {\n    callback(new Errors.EBADF('descriptor does not permit reading'));\n  } else {\n    read_data(context, ofd, buffer, offset, length, position, wrapped_cb);\n  }\n}\n\nfunction fsync(context, fd, callback) {\n  if(validateInteger(fd, callback) !== fd) return;\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    callback();\n  }\n}\n\nfunction readFile(context, path, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, null, 'r');\n\n  var flags = validate_flags(options.flag || 'r');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    function cleanup() {\n      openFiles.releaseDescriptor(fd);\n    }\n\n    fstat_file(context, ofd, function(err, fstatResult) {\n      if(err) {\n        cleanup();\n        return callback(err);\n      }\n\n      var stats = new Stats(ofd.path, fstatResult, context.name);\n\n      if(stats.isDirectory()) {\n        cleanup();\n        return callback(new Errors.EISDIR('illegal operation on directory', path));\n      }\n\n      var size = stats.size;\n      var buffer = Buffer.alloc(size);\n\n      read_data(context, ofd, buffer, 0, size, 0, function(err) {\n        cleanup();\n\n        if(err) {\n          return callback(err);\n        }\n\n        var data;\n        if(options.encoding === 'utf8') {\n          data = buffer.toString('utf8');\n        } else {\n          data = buffer;\n        }\n        callback(null, data);\n      });\n    });\n  });\n}\n\nfunction write(context, fd, buffer, offset, length, position, callback) {\n  callback = arguments[arguments.length - 1];\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else if(buffer.length - offset < length) {\n    callback(new Errors.EIO('input buffer is too small'));\n  } else {\n    write_data(context, ofd, buffer, offset, length, position, callback);\n  }\n}\n\nfunction writeFile(context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'w');\n\n  var flags = validate_flags(options.flag || 'w');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  if(!Buffer.isBuffer(data)) {\n    if(typeof data === 'number') {\n      data = '' + data;\n    }\n    data = data || '';\n    if(typeof data !== 'string') {\n      data = Buffer.from(data.toString());\n    }\n    else {\n      data = Buffer.from(data || '', options.encoding || 'utf8');\n    }\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    replace_data(context, ofd, data, 0, data.length, function(err) {\n      openFiles.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction appendFile(context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'a');\n\n  var flags = validate_flags(options.flag || 'a');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === 'number') {\n    data = '' + data;\n  }\n  if(typeof data === 'string' && options.encoding === 'utf8') {\n    data = Buffer.from(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    write_data(context, ofd, data, 0, data.length, ofd.position, function(err) {\n      openFiles.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction exists(context, path, callback) {\n  function cb(err) {\n    callback(err ? false : true);\n  }\n  stat(context, path, cb);\n}\n\nfunction validateInteger(value, callback) {\n  if (typeof value !== 'number') {\n    callback(new Errors.EINVAL('Expected integer', value));\n    return;\n  }\n\n  return value;\n}\n\n// Based on https://github.com/nodejs/node/blob/c700cc42da9cf73af9fec2098520a6c0a631d901/lib/internal/validators.js#L21\nvar octalReg = /^[0-7]+$/;\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n// Validator for mode_t (the S_* constants). Valid numbers or octal strings\n// will be masked with 0o777 to be consistent with the behavior in POSIX APIs.\nfunction validateAndMaskMode(value, def, callback) {\n  if(typeof def === 'function') {\n    callback = def;\n    def = undefined;\n  }\n\n  if (isUint32(value)) {\n    return value & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isInteger(value)) {\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    } else {\n      // 2 ** 32 === 4294967296\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    }\n  }\n\n  if (typeof value === 'string') {\n    if (!octalReg.test(value)) {\n      callback(new Errors.EINVAL('mode not a valid octal string', value));\n      return false;\n    }\n    var parsed = parseInt(value, 8);\n    return parsed & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  // TODO(BridgeAR): Only return `def` in case `value === null`\n  if (def !== undefined) {\n    return def;\n  }\n\n  callback(new Errors.EINVAL('mode not valid', value));\n  return false;\n}\n\nfunction chmod_file(context, path, mode, callback) {\n  path = normalize(path);\n\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be number', path));\n  }\n  else {\n    find_node(context, path, update_mode);\n  }\n}\n\nfunction fchmod_file(context, ofd, mode, callback) {\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be a number'));\n  }\n  else {\n    ofd.getNode(context, update_mode);\n  }\n}\n\nfunction chown_file(context, path, uid, gid, callback) {\n  path = normalize(path);\n\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  find_node(context, path, update_owner);\n}\n\nfunction fchown_file(context, ofd, uid, gid, callback) {\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  ofd.getNode(context, update_owner);\n}\n\nfunction getxattr(context, path, name, callback) {\n  getxattr_file(context, path, name, callback);\n}\n\nfunction fgetxattr(context, fd, name, callback) {\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else {\n    fgetxattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction setxattr(context, path, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  setxattr_file(context, path, name, value, flag, callback);\n}\n\nfunction fsetxattr(context, fd, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fsetxattr_file(context, ofd, name, value, flag, callback);\n  }\n}\n\nfunction removexattr(context, path, name, callback) {\n  removexattr_file(context, path, name, callback);\n}\n\nfunction fremovexattr(context, fd, name, callback) {\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fremovexattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction lseek(context, fd, offset, whence, callback) {\n  function update_descriptor_position(error, stats) {\n    if(error) {\n      callback(error);\n    } else {\n      if(stats.size + offset < 0) {\n        callback(new Errors.EINVAL('resulting file offset would be negative'));\n      } else {\n        ofd.position = stats.size + offset;\n        callback(null, ofd.position);\n      }\n    }\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  }\n\n  if('SET' === whence) {\n    if(offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position = offset;\n      callback(null, ofd.position);\n    }\n  } else if('CUR' === whence) {\n    if(ofd.position + offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position += offset;\n      callback(null, ofd.position);\n    }\n  } else if('END' === whence) {\n    fstat_file(context, ofd, update_descriptor_position);\n  } else {\n    callback(new Errors.EINVAL('whence argument is not a proper value'));\n  }\n}\n\nfunction readdir(context, path, options, callback) {\n  read_directory(context, path, options, callback);\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number') {\n    return time;\n  }\n  if (typeof time === 'object' && typeof time.getTime === 'function') {\n    return time.getTime();\n  }\n}\n\nfunction utimes(context, path, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  utimes_file(context, path, atime, mtime, callback);\n}\n\nfunction futimes(context, fd, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    futimes_file(context, ofd, atime, mtime, callback);\n  }\n}\n\nfunction chmod(context, path, mode, callback) {\n  mode = validateAndMaskMode(mode, callback);\n  if(!mode) return;\n\n  chmod_file(context, path, mode, callback);\n}\n\nfunction fchmod(context, fd, mode, callback) {\n  mode = validateAndMaskMode(mode, callback);\n  if(!mode) return;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchmod_file(context, ofd, mode, callback);\n  }\n}\n\nfunction chown(context, path, uid, gid, callback) {\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  chown_file(context, path, uid, gid, callback);\n}\n\nfunction fchown(context, fd, uid, gid, callback) {\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchown_file(context, ofd, uid, gid, callback);\n  }\n}\n\nfunction rename(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  newpath = normalize(newpath);\n\n  var oldParentPath = Path.dirname(oldpath);\n  var newParentPath = Path.dirname(newpath);\n  var oldName = Path.basename(oldpath);\n  var newName = Path.basename(newpath);\n  var oldParentDirectory, oldParentData;\n  var newParentDirectory, newParentData;\n  var ctime = Date.now();\n  var fileNode;\n\n  function update_times(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function read_new_directory(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(newParentData[newName].id, update_times);\n    }\n  }\n\n  function update_old_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      if(oldParentDirectory.id === newParentDirectory.id) {\n        oldParentData = newParentData;\n      }\n      delete oldParentData[oldName];\n      context.putObject(oldParentDirectory.data, oldParentData, read_new_directory);\n    }\n  }\n\n  function update_new_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData[newName] = oldParentData[oldName];\n      context.putObject(newParentDirectory.data, newParentData, update_old_parent_directory_data);\n    }\n  }\n\n  function check_if_new_directory_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData = result;\n      if(Object.prototype.hasOwnProperty.call(newParentData, newName)) {\n        remove_directory(context, newpath, update_new_parent_directory_data);\n      } else {\n        update_new_parent_directory_data();\n      }\n    }\n  }\n\n  function read_new_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentDirectory = result;\n      context.getObject(newParentDirectory.data, check_if_new_directory_exists);\n    }\n  }\n\n  function get_new_parent_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentData = result;\n      find_node(context, newParentPath, read_new_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentDirectory = result;\n      context.getObject(result.data, get_new_parent_directory);\n    }\n  }\n\n  function unlink_old_file(error) {\n    if(error) {\n      callback(error);\n    } else {\n      unlink_node(context, oldpath, callback);\n    }\n  }\n\n  function check_node_type(error, node) {\n    if(error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY) {\n      find_node(context, oldParentPath, read_parent_directory_data);\n    } else {\n      link_node(context, oldpath, newpath, unlink_old_file);\n    }\n  }\n\n  find_node(context, oldpath, check_node_type);\n}\n\nfunction symlink(context, srcpath, dstpath, type, callback) {\n  // NOTE: we support passing the `type` arg, but ignore it.\n  callback = arguments[arguments.length - 1];\n  make_symbolic_link(context, srcpath, dstpath, callback);\n}\n\nfunction readlink(context, path, callback) {\n  read_link(context, path, callback);\n}\n\nfunction lstat(context, path, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction truncate(context, path, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  if(validateInteger(length, callback) !== length) return;\n\n  truncate_file(context, path, length, callback);\n}\n\nfunction ftruncate(context, fd, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    if(validateInteger(length, callback) !== length) return;\n    ftruncate_file(context, ofd, length, callback);\n  }\n}\n\nmodule.exports = {\n  appendFile,\n  access,\n  chown,\n  chmod,\n  close,\n  // copyFile - https://github.com/filerjs/filer/issues/436\n  ensureRootDirectory: ensure_root_directory,\n  exists,\n  fchown,\n  fchmod,\n  // fdatasync - https://github.com/filerjs/filer/issues/653\n  fgetxattr,\n  fremovexattr,\n  fsetxattr,\n  fstat,\n  fsync,\n  ftruncate,\n  futimes,\n  getxattr,\n  // lchown - https://github.com/filerjs/filer/issues/620\n  // lchmod - https://github.com/filerjs/filer/issues/619\n  link,\n  lseek,\n  lstat,\n  mkdir,\n  mkdtemp,\n  mknod,\n  open,\n  readdir,\n  read,\n  readFile,\n  readlink,\n  // realpath - https://github.com/filerjs/filer/issues/85\n  removexattr,\n  rename,\n  rmdir,\n  setxattr,\n  stat,\n  symlink,\n  truncate,\n  // unwatchFile - implemented in interface.js\n  unlink,\n  utimes,\n  // watch - implemented in interface.js\n  // watchFile - implemented in interface.js\n  writeFile,\n  write\n};\n", "'use strict';\n\nconst { promisify } = require('es6-promisify');\n\nconst Path = require('../path.js');\n\nconst providers = require('../providers/index.js');\n\nconst Shell = require('../shell/shell.js');\nconst Intercom = require('../../lib/intercom.js');\nconst FSWatcher = require('../fs-watcher.js');\nconst Errors = require('../errors.js');\nconst {\n  nop,\n  guid: defaultGuidFn\n} = require('../shared.js');\n\nconst {\n  fsConstants,\n  FILE_SYSTEM_NAME,\n  FS_FORMAT,\n  FS_READY,\n  FS_PENDING,\n  FS_ERROR,\n  FS_NODUPEIDCHECK,\n  STDIN,\n  STDOUT,\n  STDERR\n} = require('../constants.js');\n\n// The core fs operations live on impl\nconst impl = require('./implementation.js');\n\n// node.js supports a calling pattern that leaves off a callback.\nfunction maybeCallback(callback) {\n  if (typeof callback === 'function') {\n    return callback;\n  }\n  return function (err) {\n    if (err) {\n      throw err;\n    }\n  };\n}\n\n// Default callback that logs an error if passed in\nfunction defaultCallback(err) {\n  if (err) {\n    /* eslint no-console: 0 */\n    console.error('Filer error: ', err);\n  }\n}\n// Get a path (String) from a file:// URL. Support URL() like objects\n// https://github.com/nodejs/node/blob/968e901aff38a343b1de4addebf79fd8fa991c59/lib/internal/url.js#L1381\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!(fileURLOrPath &&\n    fileURLOrPath.protocol &&\n    fileURLOrPath.pathname)) {\n    return fileURLOrPath;\n  }\n\n  if (fileURLOrPath.protocol !== 'file:') {\n    throw new Errors.EINVAL('only file: URLs are supported for paths', fileURLOrPath);\n  }\n\n  const pathname = fileURLOrPath.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new Errors.EINVAL('file: URLs must not include encoded / characters', fileURLOrPath);\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname);\n}\n\n// Allow Buffers for paths. Assumes we want UTF8.\nfunction toPathIfBuffer(bufferOrPath) {\n  return Buffer.isBuffer(bufferOrPath) ? bufferOrPath.toString() : bufferOrPath;\n}\n\nfunction validatePath(path, allowRelative) {\n  if (!path) {\n    return new Errors.EINVAL('Path must be a string', path);\n  } else if (Path.isNull(path)) {\n    return new Errors.EINVAL('Path must be a string without null bytes.', path);\n  } else if (!allowRelative && !Path.isAbsolute(path)) {\n    return new Errors.EINVAL('Path must be absolute.', path);\n  }\n}\n\nfunction processPathArg(args, idx, allowRelative) {\n  let path = args[idx];\n  path = toPathIfFileURL(path);\n  path = toPathIfBuffer(path);\n\n  // Some methods specifically allow for rel paths (eg symlink with srcPath)\n  let err = validatePath(path, allowRelative);\n  if (err) {\n    throw err;\n  }\n\n  // Overwrite path arg with converted and validated path\n  args[idx] = path;\n}\n\n/**\n * FileSystem\n *\n * A FileSystem takes an `options` object, which can specify a number of,\n * options.  All options are optional, and include:\n *\n * name: the name of the file system, defaults to \"local\"\n *\n * flags: one or more flags to use when creating/opening the file system.\n *        For example: \"FORMAT\" will cause the file system to be formatted.\n *        No explicit flags are set by default.\n *\n * provider: an explicit storage provider to use for the file\n *           system's database context provider.  A number of context\n *           providers are included (see /src/providers), and users\n *           can write one of their own and pass it in to be used.\n *           By default an IndexedDB provider is used.\n *\n * guid: a function for generating unique IDs for nodes in the filesystem.\n *       Use this to override the built-in UUID generation. (Used mainly for tests).\n *\n * callback: a callback function to be executed when the file system becomes\n *           ready for use. Depending on the context provider used, this might\n *           be right away, or could take some time. The callback should expect\n *           an `error` argument, which will be null if everything worked.  Also\n *           users should check the file system's `readyState` and `error`\n *           properties to make sure it is usable.\n */\nfunction FileSystem(options, callback) {\n  options = options || {};\n  callback = callback || defaultCallback;\n\n  const flags = options.flags || [];\n  const guid = options.guid ? options.guid : defaultGuidFn;\n  const provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME);\n  // If we're given a provider, match its name unless we get an explicit name\n  const name = options.name || provider.name;\n  const forceFormatting = flags.includes(FS_FORMAT);\n\n  const fs = this;\n  fs.readyState = FS_PENDING;\n  fs.name = name;\n  fs.error = null;\n\n  fs.stdin = STDIN;\n  fs.stdout = STDOUT;\n  fs.stderr = STDERR;\n\n  // Expose Node's fs.constants to users\n  fs.constants = fsConstants;\n  // Node also forwards the access mode flags onto fs\n  fs.F_OK = fsConstants.F_OK;\n  fs.R_OK = fsConstants.R_OK;\n  fs.W_OK = fsConstants.W_OK;\n  fs.X_OK = fsConstants.X_OK;\n\n  // Expose Shell constructor\n  this.Shell = Shell.bind(undefined, this);\n\n  // Safely expose the operation queue\n  let queue = [];\n  this.queueOrRun = function (operation) {\n    let error;\n\n    if (FS_READY === fs.readyState) {\n      operation.call(fs);\n    } else if (FS_ERROR === fs.readyState) {\n      error = new Errors.EFILESYSTEMERROR('unknown error');\n    } else {\n      queue.push(operation);\n    }\n\n    return error;\n  };\n  function runQueued() {\n    queue.forEach(function (operation) {\n      operation.call(this);\n    }.bind(fs));\n    queue = null;\n  }\n\n  // We support the optional `options` arg from node, but ignore it\n  this.watch = function (filename, options, listener) {\n    if (Path.isNull(filename)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n    if (typeof options === 'function') {\n      listener = options;\n      options = {};\n    }\n    options = options || {};\n    listener = listener || nop;\n\n    const watcher = new FSWatcher();\n    watcher.start(filename, false, options.recursive);\n    watcher.on('change', listener);\n\n    return watcher;\n  };\n\n  // Deal with various approaches to node ID creation\n  function wrappedGuidFn(context) {\n    return function (callback) {\n      // Skip the duplicate ID check if asked to\n      if (flags.includes(FS_NODUPEIDCHECK)) {\n        callback(null, guid());\n        return;\n      }\n\n      // Otherwise (default) make sure this id is unused first\n      function guidWithCheck(callback) {\n        const id = guid();\n        context.getObject(id, function (err, value) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          // If this id is unused, use it, otherwise find another\n          if (!value) {\n            callback(null, id);\n          } else {\n            guidWithCheck(callback);\n          }\n        });\n      }\n      guidWithCheck(callback);\n    };\n  }\n\n  // Let other instances (in this or other windows) know about\n  // any changes to this fs instance.\n  function broadcastChanges(changes) {\n    if (!changes.length) {\n      return;\n    }\n    const intercom = Intercom.getInstance();\n    changes.forEach(function (change) {\n      intercom.emit(change.event, change.path);\n    });\n  }\n\n  // Open file system storage provider\n  provider.open(function (err) {\n    function complete(error) {\n      function wrappedContext(methodName) {\n        let context = provider[methodName]();\n        context.name = name;\n        context.flags = flags;\n        context.changes = [];\n        context.guid = wrappedGuidFn(context);\n\n        // When the context is finished, let the fs deal with any change events\n        context.close = function () {\n          let changes = context.changes;\n          broadcastChanges(changes);\n          changes.length = 0;\n        };\n\n        return context;\n      }\n\n      // Wrap the provider so we can extend the context with fs flags and\n      // an array of changes (e.g., watch event 'change' and 'rename' events\n      // for paths updated during the lifetime of the context). From this\n      // point forward we won't call open again, so it's safe to drop it.\n      fs.provider = {\n        openReadWriteContext: function () {\n          return wrappedContext('getReadWriteContext');\n        },\n        openReadOnlyContext: function () {\n          return wrappedContext('getReadOnlyContext');\n        }\n      };\n\n      if (error) {\n        fs.readyState = FS_ERROR;\n      } else {\n        fs.readyState = FS_READY;\n      }\n      runQueued();\n      callback(error, fs);\n    }\n\n    if (err) {\n      return complete(err);\n    }\n\n    const context = provider.getReadWriteContext();\n    context.guid = wrappedGuidFn(context);\n\n    // Mount the filesystem, formatting if necessary\n    if (forceFormatting) {\n      // Wipe the storage provider, then write root block\n      context.clear(function (err) {\n        if (err) {\n          return complete(err);\n        }\n        impl.ensureRootDirectory(context, complete);\n      });\n    } else {\n      // Use existing (or create new) root and mount\n      impl.ensureRootDirectory(context, complete);\n    }\n  });\n  FileSystem.prototype.promises = {};\n\n  /**\n   * Public API for FileSystem. All node.js methods that are exposed on fs.promises\n   * include `promise: true`.  We also include our own extra methods, but skip the\n   * fd versions to match node.js, which puts these on a `FileHandle` object.\n   * Any method that deals with path argument(s) also includes the position of\n   * those args in one of `absPathArgs: [...]` or `relPathArgs: [...]`, so they\n   * can be processed and validated before being passed on to the method.\n   */\n  [\n    { name: 'appendFile', promises: true, absPathArgs: [0] },\n    { name: 'access', promises: true, absPathArgs: [0] },\n    { name: 'chown', promises: true, absPathArgs: [0] },\n    { name: 'chmod', promises: true, absPathArgs: [0] },\n    { name: 'close' },\n    // copyFile - https://github.com/filerjs/filer/issues/436\n    { name: 'exists', absPathArgs: [0] },\n    { name: 'fchown' },\n    { name: 'fchmod' },\n    // fdatasync - https://github.com/filerjs/filer/issues/653\n    { name: 'fgetxattr' },\n    { name: 'fremovexattr' },\n    { name: 'fsetxattr' },\n    { name: 'fstat' },\n    { name: 'fsync' },\n    { name: 'ftruncate' },\n    { name: 'futimes' },\n    { name: 'getxattr', promises: true, absPathArgs: [0] },\n    // lchown - https://github.com/filerjs/filer/issues/620\n    // lchmod - https://github.com/filerjs/filer/issues/619\n    { name: 'link', promises: true, absPathArgs: [0, 1] },\n    { name: 'lseek' },\n    { name: 'lstat', promises: true },\n    { name: 'mkdir', promises: true, absPathArgs: [0] },\n    { name: 'mkdtemp', promises: true },\n    { name: 'mknod', promises: true, absPathArgs: [0] },\n    { name: 'open', promises: true, absPathArgs: [0] },\n    { name: 'readdir', promises: true, absPathArgs: [0] },\n    { name: 'read' },\n    { name: 'readFile', promises: true, absPathArgs: [0] },\n    { name: 'readlink', promises: true, absPathArgs: [0] },\n    // realpath - https://github.com/filerjs/filer/issues/85\n    { name: 'removexattr', promises: true, absPathArgs: [0] },\n    { name: 'rename', promises: true, absPathArgs: [0, 1] },\n    { name: 'rmdir', promises: true, absPathArgs: [0] },\n    { name: 'setxattr', promises: true, absPathArgs: [0] },\n    { name: 'stat', promises: true, absPathArgs: [0] },\n    { name: 'symlink', promises: true, relPathArgs: [0], absPathArgs: [1] },\n    { name: 'truncate', promises: true, absPathArgs: [0] },\n    // unwatchFile - https://github.com/filerjs/filer/pull/553\n    { name: 'unlink', promises: true, absPathArgs: [0] },\n    { name: 'utimes', promises: true, absPathArgs: [0] },\n    // watch - implemented above in `this.watch`\n    // watchFile - https://github.com/filerjs/filer/issues/654\n    { name: 'writeFile', promises: true, absPathArgs: [0] },\n    { name: 'write' }\n  ].forEach(function (method) {\n    const methodName = method.name;\n    const shouldPromisify = method.promises === true;\n\n    FileSystem.prototype[methodName] = function () {\n      const fs = this;\n      const args = Array.prototype.slice.call(arguments, 0);\n      const lastArgIndex = args.length - 1;\n\n      // We may or may not get a callback, and since node.js supports\n      // fire-and-forget style fs operations, we have to dance a bit here.\n      const missingCallback = typeof args[lastArgIndex] !== 'function';\n      const callback = maybeCallback(args[lastArgIndex]);\n\n      // Deal with path arguments, validating and normalizing Buffer and file:// URLs\n      if (method.absPathArgs) {\n        method.absPathArgs.forEach(pathArg => processPathArg(args, pathArg, false));\n      }\n      if (method.relPathArgs) {\n        method.relPathArgs.forEach(pathArg => processPathArg(args, pathArg, true));\n      }\n\n      const error = fs.queueOrRun(function () {\n        const context = fs.provider.openReadWriteContext();\n\n        // Fail early if the filesystem is in an error state (e.g.,\n        // provider failed to open.\n        if (FS_ERROR === fs.readyState) {\n          const err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');\n          return callback.call(fs, err);\n        }\n\n        // Wrap the callback so we can explicitly close the context\n        function complete() {\n          context.close();\n          callback.apply(fs, arguments);\n        }\n\n        // Either add or replace the callback with our wrapper complete()\n        if (missingCallback) {\n          args.push(complete);\n        } else {\n          args[lastArgIndex] = complete;\n        }\n\n        // Forward this call to the impl's version, using the following\n        // call signature, with complete() as the callback/last-arg now:\n        // fn(fs, context, arg0, arg1, ... , complete);\n        const fnArgs = [context].concat(args);\n        impl[methodName].apply(null, fnArgs);\n      });\n      if (error) {\n        callback(error);\n      }\n    };\n\n    // Add to fs.promises if appropriate\n    if (shouldPromisify) {\n      FileSystem.prototype.promises[methodName] = promisify(FileSystem.prototype[methodName].bind(fs));\n    }\n  });\n\n}\n\n// Expose storage providers on FileSystem constructor\nFileSystem.providers = providers;\n\nmodule.exports = FileSystem;\n", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/**\n * @template T\n * @param fn {(function(): any) | undefined}\n * @returns {function(): T}\n */\nconst memoize = fn => {\n  let cache = false;\n  /** @type {T} */\n  let result;\n  return () => {\n    if (cache) {\n      return result;\n    }\n    result = /** @type {function(): any} */fn();\n    cache = true;\n    // Allow to clean up memory for fn\n    // and all dependent resources\n    // eslint-disable-next-line no-undefined, no-param-reassign\n    fn = undefined;\n    return result;\n  };\n};\nvar _default = memoize;\nexports.default = _default;", "\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\n\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n    return exclusive ? \"<\" : \"<=\";\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ? /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax : /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n    if (j > -1) {\n      return values[j];\n    }\n    return [Infinity, true];\n  }\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n    this._right = [];\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end;\n\n    // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    }\n\n    // e.g. 4 < x < \u221E\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    }\n\n    // e.g. \u221E < x < 4\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n}\nmodule.exports = Range;", "\"use strict\";\n\nconst Range = require(\"./Range\");\n\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = {\n    ...schema\n  };\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n  return [type].concat(hints);\n};\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n  const rangeFormat = range.format(logic);\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n  return hints;\n};", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _memorize = _interopRequireDefault(require(\"./util/memorize\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n/** @enum {number} */\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n\n/**\n * @param {string} value\n * @returns {value is number}\n */\nfunction isNumeric(value) {\n  return /^-?\\d+$/.test(value);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.instancePath ? error.instancePath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[/** @type {keyof typeof SPECIFICITY} */error.keyword] || 2);\n  return newChildren;\n}\n\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n  return i + 1;\n}\n\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n  while (i > 0) {\n    const child = children[i];\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n    i -= 1;\n  }\n  if (i === 0) {\n    result.push(children[i]);\n  }\n  return result.reverse();\n}\n\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n  return schema;\n}\n\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n\n/**\n * @param {string} type\n * @returns {string}\n */\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n  return \"a\";\n}\n\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n  return \"\";\n}\n\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\nconst getUtilHints = (0, _memorize.default)(() =>\n// eslint-disable-next-line global-require\nrequire(\"./util/hints\"));\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    const util = getUtilHints();\n    return util.numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    const util = getUtilHints();\n    return util.stringHints(schema, logic);\n  }\n  return [];\n}\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n\n    /** @type {string} */\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n    this.errors = errors;\n    /** @type {Schema} */\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n\n    /** @type {string} */\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n\n    /** @type {PostFormatter | null} */\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n\n    /** @type {string} */\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[/** @type {keyof Schema} */newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  }\n\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n    if ( /** @type {Schema & {instanceof: string | Array<string>}} */schema.instanceof) {\n      const {\n        instanceof: value\n      } = /** @type {Schema & {instanceof: string | Array<string>}} */schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n    if (schema.enum) {\n      const enumValues = /** @type {Array<any>} */schema.enum.map(item => {\n        if (item === null && schema.undefinedAsNull) {\n          return `${JSON.stringify(item)} | undefined`;\n        }\n        return JSON.stringify(item);\n      }).join(\" | \");\n      return `${enumValues}`;\n    }\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n    if (schema.oneOf) {\n      return (/** @type {Array<Schema>} */schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.anyOf) {\n      return (/** @type {Array<Schema>} */schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.allOf) {\n      return (/** @type {Array<Schema>} */schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \")\n      );\n    }\n    if ( /** @type {JSONSchema7} */schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } = /** @type {JSONSchema7} */schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      /** @type {Array<string>} */\n      // @ts-ignore\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set( /** @type {Array<string>} */[].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property);\n\n        // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"\u2026\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } = /** @type {Schema & {patternRequired?: Array<string>;}} */schema;\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    }\n\n    // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n    /* istanbul ignore next */\n    return JSON.stringify(schema, null, 2);\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[/** @type {keyof Schema} */additionalPath[i]];\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = \"\";\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n  formatValidationError(error) {\n    const {\n      keyword,\n      instancePath: errorInstancePath\n    } = error;\n    const splittedInstancePath = errorInstancePath.split(\"/\");\n    /**\n     * @type {Array<string>}\n     */\n    const defaultValue = [];\n    const prettyInstancePath = splittedInstancePath.reduce((acc, val) => {\n      if (val.length > 0) {\n        if (isNumeric(val)) {\n          acc.push(`[${val}]`);\n        } else if (/^\\[/.test(val)) {\n          acc.push(val);\n        } else {\n          acc.push(`.${val}`);\n        }\n      }\n      return acc;\n    }, defaultValue).join(\"\");\n    const instancePath = `${this.baseDataPath}${prettyInstancePath}`;\n\n    // const { keyword, instancePath: errorInstancePath } = error;\n    // const instancePath = `${this.baseDataPath}${errorInstancePath.replace(/\\//g, '.')}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          switch (params.type) {\n            case \"number\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"integer\":\n              return `${instancePath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"string\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"boolean\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"array\":\n              return `${instancePath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"object\":\n              return `${instancePath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"null\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            default:\n              return `${instancePath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } = params;\n          return `${instancePath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } = params;\n          return `${instancePath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"formatMinimum\":\n      case \"formatExclusiveMinimum\":\n      case \"formatMaximum\":\n      case \"formatExclusiveMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          return `${instancePath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          const [, ...hints] = getHints( /** @type {Schema} */parentSchema, true);\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n          return `${instancePath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } = params;\n          return `${instancePath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } = params;\n          return `${instancePath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          const length = limit - 1;\n          return `${instancePath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          const max = limit + 1;\n          return `${instancePath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } = params;\n          return `${instancePath} should not contain the item '${\n          /** @type {{ data: Array<any> }} **/error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty = params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean( /** @type {Schema} */\n          parentSchema.properties && /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${instancePath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } = params;\n          return `${instancePath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } = params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${instancePath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } = params;\n          return `${instancePath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n          if (parentSchema && /** @type {Schema} */\n          parentSchema.enum && /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${instancePath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"not\":\n        {\n          const postfix = likeObject( /** @type {Schema} */error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n          if (canApplyNot(error.schema)) {\n            return `${instancePath} should be any ${schemaOutput}${postfix}.`;\n          }\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${instancePath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n            let filteredChildren = filterChildren(children);\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } = params;\n          return `${instancePath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${instancePath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      /* istanbul ignore next */\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2);\n\n          // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n          return `${instancePath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n}\nvar _default = ValidationError;\nexports.default = _default;", "// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n", "import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n", "import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n", "import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n", "import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n", "import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n", "import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n", "import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n", "import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n", "import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n", "import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n", "import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n", "import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n", "import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n", "import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n", "import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n", "import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n", "import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n", "{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n", "'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n", "'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n", "'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n", "'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme)\n    uriTokens.push(':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?')\n    uriTokens.push(components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#')\n    uriTokens.push(components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.userinfo !== undefined) {\n        parsed.userinfo = unescape(parsed.userinfo)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n", "import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n", "export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n", "import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n", "// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n", "import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n", "import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n", "import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n", "import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n", "import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n", "import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n", "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n", "import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n", "import type {CodeKeywordDefinition, KeywordCxt} from \"ajv\"\nimport {_} from \"ajv/dist/compile/codegen\"\n\nconst TYPES = [\"undefined\", \"string\", \"number\", \"object\", \"function\", \"boolean\", \"symbol\"]\n\nexport default function getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"typeof\",\n    schemaType: [\"string\", \"array\"],\n    code(cxt: KeywordCxt) {\n      const {data, schema, schemaValue} = cxt\n      cxt.fail(\n        typeof schema == \"string\"\n          ? _`typeof ${data} != ${schema}`\n          : _`${schemaValue}.indexOf(typeof ${data}) < 0`\n      )\n    },\n    metaSchema: {\n      anyOf: [\n        {type: \"string\", enum: TYPES},\n        {type: \"array\", items: {type: \"string\", enum: TYPES}},\n      ],\n    },\n  }\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/typeof\"\n\nconst typeofPlugin: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default typeofPlugin\nmodule.exports = typeofPlugin\n", "import type {FuncKeywordDefinition} from \"ajv\"\n\ntype Constructor = new (...args: any[]) => any\n\nconst CONSTRUCTORS: Record<string, Constructor | undefined> = {\n  Object,\n  Array,\n  Function,\n  Number,\n  String,\n  Date,\n  RegExp,\n}\n\n/* istanbul ignore else */\nif (typeof Buffer != \"undefined\") CONSTRUCTORS.Buffer = Buffer\n\n/* istanbul ignore else */\nif (typeof Promise != \"undefined\") CONSTRUCTORS.Promise = Promise\n\nconst getDef: (() => FuncKeywordDefinition) & {\n  CONSTRUCTORS: typeof CONSTRUCTORS\n} = Object.assign(_getDef, {CONSTRUCTORS})\n\nfunction _getDef(): FuncKeywordDefinition {\n  return {\n    keyword: \"instanceof\",\n    schemaType: [\"string\", \"array\"],\n    compile(schema: string | string[]) {\n      if (typeof schema == \"string\") {\n        const C = getConstructor(schema)\n        return (data) => data instanceof C\n      }\n\n      if (Array.isArray(schema)) {\n        const constructors = schema.map(getConstructor)\n        return (data) => {\n          for (const C of constructors) {\n            if (data instanceof C) return true\n          }\n          return false\n        }\n      }\n\n      /* istanbul ignore next */\n      throw new Error(\"ajv implementation error\")\n    },\n    metaSchema: {\n      anyOf: [{type: \"string\"}, {type: \"array\", items: {type: \"string\"}}],\n    },\n  }\n}\n\nfunction getConstructor(c: string): Constructor {\n  const C = CONSTRUCTORS[c]\n  if (C) return C\n  throw new Error(`invalid \"instanceof\" keyword value ${c}`)\n}\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/instanceof\"\n\nconst instanceofPlugin: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default instanceofPlugin\nmodule.exports = instanceofPlugin\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\n\ntype RangeKwd = \"range\" | \"exclusiveRange\"\n\nexport default function getRangeDef(keyword: RangeKwd): GetDefinition<MacroKeywordDefinition> {\n  return () => ({\n    keyword,\n    type: \"number\",\n    schemaType: \"array\",\n    macro: function ([min, max]: [number, number]) {\n      validateRangeSchema(min, max)\n      return keyword === \"range\"\n        ? {minimum: min, maximum: max}\n        : {exclusiveMinimum: min, exclusiveMaximum: max}\n    },\n    metaSchema: {\n      type: \"array\",\n      minItems: 2,\n      maxItems: 2,\n      items: {type: \"number\"},\n    },\n  })\n\n  function validateRangeSchema(min: number, max: number): void {\n    if (min > max || (keyword === \"exclusiveRange\" && min === max)) {\n      throw new Error(\"There are no numbers in range\")\n    }\n  }\n}\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\nimport getRangeDef from \"./_range\"\n\nconst getDef: GetDefinition<MacroKeywordDefinition> = getRangeDef(\"range\")\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/range\"\n\nconst range: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default range\nmodule.exports = range\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\nimport getRangeDef from \"./_range\"\n\nconst getDef: GetDefinition<MacroKeywordDefinition> = getRangeDef(\"exclusiveRange\")\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/exclusiveRange\"\n\nconst exclusiveRange: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default exclusiveRange\nmodule.exports = exclusiveRange\n", "import type {DefinitionOptions} from \"./_types\"\nimport type {SchemaObject, KeywordCxt, Name} from \"ajv\"\nimport {_} from \"ajv/dist/compile/codegen\"\n\nconst META_SCHEMA_ID = \"http://json-schema.org/schema\"\n\nexport function metaSchemaRef({defaultMeta}: DefinitionOptions = {}): SchemaObject {\n  return defaultMeta === false ? {} : {$ref: defaultMeta || META_SCHEMA_ID}\n}\n\nexport function usePattern(\n  {gen, it: {opts}}: KeywordCxt,\n  pattern: string,\n  flags = opts.unicodeRegExp ? \"u\" : \"\"\n): Name {\n  const rx = new RegExp(pattern, flags)\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`new RegExp(${pattern}, ${flags})`,\n  })\n}\n", "import type {CodeKeywordDefinition, KeywordCxt, JSONSchemaType, Name} from \"ajv\"\nimport {_} from \"ajv/dist/compile/codegen\"\nimport {usePattern} from \"./_util\"\n\ninterface RegexpSchema {\n  pattern: string\n  flags?: string\n}\n\nconst regexpMetaSchema: JSONSchemaType<RegexpSchema> = {\n  type: \"object\",\n  properties: {\n    pattern: {type: \"string\"},\n    flags: {type: \"string\", nullable: true},\n  },\n  required: [\"pattern\"],\n  additionalProperties: false,\n}\n\nconst metaRegexp = /^\\/(.*)\\/([gimuy]*)$/\n\nexport default function getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"regexp\",\n    type: \"string\",\n    schemaType: [\"string\", \"object\"],\n    code(cxt: KeywordCxt) {\n      const {data, schema} = cxt\n      const regx = getRegExp(schema)\n      cxt.pass(_`${regx}.test(${data})`)\n\n      function getRegExp(sch: string | RegexpSchema): Name {\n        if (typeof sch == \"object\") return usePattern(cxt, sch.pattern, sch.flags)\n        const rx = metaRegexp.exec(sch)\n        if (rx) return usePattern(cxt, rx[1], rx[2])\n        throw new Error(\"cannot parse string into RegExp\")\n      }\n    },\n    metaSchema: {\n      anyOf: [{type: \"string\"}, regexpMetaSchema],\n    },\n  }\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/regexp\"\n\nconst regexp: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default regexp\nmodule.exports = regexp\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordCxt, Code, Name} from \"ajv\"\nimport {_, stringify, getProperty} from \"ajv/dist/compile/codegen\"\n\ntype TransformName =\n  | \"trimStart\"\n  | \"trimEnd\"\n  | \"trimLeft\"\n  | \"trimRight\"\n  | \"trim\"\n  | \"toLowerCase\"\n  | \"toUpperCase\"\n  | \"toEnumCase\"\n\ninterface TransformConfig {\n  hash: Record<string, string | undefined>\n}\n\ntype Transform = (s: string, cfg?: TransformConfig) => string\n\nconst transform: {[key in TransformName]: Transform} = {\n  trimStart: (s) => s.trimStart(),\n  trimEnd: (s) => s.trimEnd(),\n  trimLeft: (s) => s.trimStart(),\n  trimRight: (s) => s.trimEnd(),\n  trim: (s) => s.trim(),\n  toLowerCase: (s) => s.toLowerCase(),\n  toUpperCase: (s) => s.toUpperCase(),\n  toEnumCase: (s, cfg) => cfg?.hash[configKey(s)] || s,\n}\n\nconst getDef: (() => CodeKeywordDefinition) & {\n  transform: typeof transform\n} = Object.assign(_getDef, {transform})\n\nfunction _getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt: KeywordCxt) {\n      const {gen, data, schema, parentSchema, it} = cxt\n      const {parentData, parentDataProperty} = it\n      const tNames: string[] = schema\n      if (!tNames.length) return\n      let cfg: Name | undefined\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema)\n        cfg = gen.scopeValue(\"obj\", {ref: config, code: stringify(config)})\n      }\n      gen.if(_`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()))\n        gen.assign(_`${parentData}[${parentDataProperty}]`, data)\n      })\n\n      function transformExpr(ts: string[]): Code {\n        if (!ts.length) return data\n        const t = ts.pop() as string\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`)\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t as TransformName],\n          code: _`require(\"ajv-keywords/dist/definitions/transform\").transform${getProperty(t)}`,\n        })\n        const arg = transformExpr(ts)\n        return cfg && t === \"toEnumCase\" ? _`${func}(${arg}, ${cfg})` : _`${func}(${arg})`\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", enum: Object.keys(transform)},\n    },\n  }\n}\n\nfunction getEnumCaseCfg(parentSchema: AnySchemaObject): TransformConfig {\n  // build hash table to enum values\n  const cfg: TransformConfig = {hash: {}}\n\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"')\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue\n    const k = configKey(v)\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique')\n    }\n    cfg.hash[k] = v\n  }\n\n  return cfg\n}\n\nfunction configKey(s: string): string {\n  return s.toLowerCase()\n}\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/transform\"\n\nconst transform: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default transform\nmodule.exports = transform\n", "import type {FuncKeywordDefinition, AnySchemaObject} from \"ajv\"\nimport equal = require(\"fast-deep-equal\")\n\nconst SCALAR_TYPES = [\"number\", \"integer\", \"string\", \"boolean\", \"null\"]\n\nexport default function getDef(): FuncKeywordDefinition {\n  return {\n    keyword: \"uniqueItemProperties\",\n    type: \"array\",\n    schemaType: \"array\",\n    compile(keys: string[], parentSchema: AnySchemaObject) {\n      const scalar = getScalarKeys(keys, parentSchema)\n\n      return (data) => {\n        if (data.length <= 1) return true\n        for (let k = 0; k < keys.length; k++) {\n          const key = keys[k]\n          if (scalar[k]) {\n            const hash: Record<string, any> = {}\n            for (const x of data) {\n              if (!x || typeof x != \"object\") continue\n              let p = x[key]\n              if (p && typeof p == \"object\") continue\n              if (typeof p == \"string\") p = '\"' + p\n              if (hash[p]) return false\n              hash[p] = true\n            }\n          } else {\n            for (let i = data.length; i--; ) {\n              const x = data[i]\n              if (!x || typeof x != \"object\") continue\n              for (let j = i; j--; ) {\n                const y = data[j]\n                if (y && typeof y == \"object\" && equal(x[key], y[key])) return false\n              }\n            }\n          }\n        }\n        return true\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\"},\n    },\n  }\n}\n\nfunction getScalarKeys(keys: string[], schema: AnySchemaObject): boolean[] {\n  return keys.map((key) => {\n    const t = schema.items?.properties?.[key]?.type\n    return Array.isArray(t)\n      ? !t.includes(\"object\") && !t.includes(\"array\")\n      : SCALAR_TYPES.includes(t)\n  })\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/uniqueItemProperties\"\n\nconst uniqueItemProperties: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default uniqueItemProperties\nmodule.exports = uniqueItemProperties\n", "import type {MacroKeywordDefinition} from \"ajv\"\n\nexport default function getDef(): MacroKeywordDefinition {\n  return {\n    keyword: \"allRequired\",\n    type: \"object\",\n    schemaType: \"boolean\",\n    macro(schema: boolean, parentSchema) {\n      if (!schema) return true\n      const required = Object.keys(parentSchema.properties)\n      if (required.length === 0) return true\n      return {required}\n    },\n    dependencies: [\"properties\"],\n  }\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/allRequired\"\n\nconst allRequired: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default allRequired\nmodule.exports = allRequired\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\n\ntype RequiredKwd = \"anyRequired\" | \"oneRequired\"\n\nexport default function getRequiredDef(\n  keyword: RequiredKwd\n): GetDefinition<MacroKeywordDefinition> {\n  return () => ({\n    keyword,\n    type: \"object\",\n    schemaType: \"array\",\n    macro(schema: string[]) {\n      if (schema.length === 0) return true\n      if (schema.length === 1) return {required: schema}\n      const comb = keyword === \"anyRequired\" ? \"anyOf\" : \"oneOf\"\n      return {[comb]: schema.map((p) => ({required: [p]}))}\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\"},\n    },\n  })\n}\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\nimport getRequiredDef from \"./_required\"\n\nconst getDef: GetDefinition<MacroKeywordDefinition> = getRequiredDef(\"anyRequired\")\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/anyRequired\"\n\nconst anyRequired: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default anyRequired\nmodule.exports = anyRequired\n", "import type {MacroKeywordDefinition} from \"ajv\"\nimport type {GetDefinition} from \"./_types\"\nimport getRequiredDef from \"./_required\"\n\nconst getDef: GetDefinition<MacroKeywordDefinition> = getRequiredDef(\"oneRequired\")\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/oneRequired\"\n\nconst oneRequired: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default oneRequired\nmodule.exports = oneRequired\n", "import type {CodeKeywordDefinition, KeywordCxt, KeywordErrorDefinition, ErrorObject} from \"ajv\"\nimport {_, str, and} from \"ajv/dist/compile/codegen\"\nimport {usePattern} from \"./_util\"\n\nexport type PatternRequiredError = ErrorObject<\"patternRequired\", {missingPattern: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingPattern}}) =>\n    str`should have property matching pattern '${missingPattern}'`,\n  params: ({params: {missingPattern}}) => _`{missingPattern: ${missingPattern}}`,\n}\n\nexport default function getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"patternRequired\",\n    type: \"object\",\n    schemaType: \"array\",\n    error,\n    code(cxt: KeywordCxt) {\n      const {gen, schema, data} = cxt\n      if (schema.length === 0) return\n      const valid = gen.let(\"valid\", true)\n      for (const pat of schema) validateProperties(pat)\n\n      function validateProperties(pattern: string): void {\n        const matched = gen.let(\"matched\", false)\n\n        gen.forIn(\"key\", data, (key) => {\n          gen.assign(matched, _`${usePattern(cxt, pattern)}.test(${key})`)\n          gen.if(matched, () => gen.break())\n        })\n\n        cxt.setParams({missingPattern: pattern})\n        gen.assign(valid, and(valid, matched))\n        cxt.pass(valid)\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", format: \"regex\"},\n      uniqueItems: true,\n    },\n  }\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/patternRequired\"\n\nconst patternRequired: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default patternRequired\nmodule.exports = patternRequired\n", "import type {MacroKeywordDefinition} from \"ajv\"\n\nexport default function getDef(): MacroKeywordDefinition {\n  return {\n    keyword: \"prohibited\",\n    type: \"object\",\n    schemaType: \"array\",\n    macro: function (schema: string[]) {\n      if (schema.length === 0) return true\n      if (schema.length === 1) return {not: {required: schema}}\n      return {not: {anyOf: schema.map((p) => ({required: [p]}))}}\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\"},\n    },\n  }\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/prohibited\"\n\nconst prohibited: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default prohibited\nmodule.exports = prohibited\n", "import type {MacroKeywordDefinition, SchemaObject, Schema} from \"ajv\"\nimport type {DefinitionOptions} from \"./_types\"\nimport {metaSchemaRef} from \"./_util\"\n\nexport default function getDef(opts?: DefinitionOptions): MacroKeywordDefinition {\n  return {\n    keyword: \"deepProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    macro: function (schema: Record<string, SchemaObject>) {\n      const allOf = []\n      for (const pointer in schema) allOf.push(getSchema(pointer, schema[pointer]))\n      return {allOf}\n    },\n    metaSchema: {\n      type: \"object\",\n      propertyNames: {type: \"string\", format: \"json-pointer\"},\n      additionalProperties: metaSchemaRef(opts),\n    },\n  }\n}\n\nfunction getSchema(jsonPointer: string, schema: SchemaObject): SchemaObject {\n  const segments = jsonPointer.split(\"/\")\n  const rootSchema: SchemaObject = {}\n  let pointerSchema: SchemaObject = rootSchema\n  for (let i = 1; i < segments.length; i++) {\n    let segment: string = segments[i]\n    const isLast = i === segments.length - 1\n    segment = unescapeJsonPointer(segment)\n    const properties: Record<string, Schema> = (pointerSchema.properties = {})\n    let items: SchemaObject[] | undefined\n    if (/[0-9]+/.test(segment)) {\n      let count = +segment\n      items = pointerSchema.items = []\n      pointerSchema.type = [\"object\", \"array\"]\n      while (count--) items.push({})\n    } else {\n      pointerSchema.type = \"object\"\n    }\n    pointerSchema = isLast ? schema : {}\n    properties[segment] = pointerSchema\n    if (items) items.push(pointerSchema)\n  }\n  return rootSchema\n}\n\nfunction unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/deepProperties\"\nimport type {DefinitionOptions} from \"../definitions/_types\"\n\nconst deepProperties: Plugin<DefinitionOptions> = (ajv, opts?: DefinitionOptions) =>\n  ajv.addKeyword(getDef(opts))\n\nexport default deepProperties\nmodule.exports = deepProperties\n", "import type {CodeKeywordDefinition, KeywordCxt} from \"ajv\"\nimport {_, or, and, getProperty, Code} from \"ajv/dist/compile/codegen\"\n\nexport default function getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"deepRequired\",\n    type: \"object\",\n    schemaType: \"array\",\n    code(ctx: KeywordCxt) {\n      const {schema, data} = ctx\n      const props = (schema as string[]).map((jp: string) => _`(${getData(jp)}) === undefined`)\n      ctx.fail(or(...props))\n\n      function getData(jsonPointer: string): Code {\n        if (jsonPointer === \"\") throw new Error(\"empty JSON pointer not allowed\")\n        const segments = jsonPointer.split(\"/\")\n        let x: Code = data\n        const xs = segments.map((s, i) =>\n          i ? (x = _`${x}${getProperty(unescapeJPSegment(s))}`) : x\n        )\n        return and(...xs)\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", format: \"json-pointer\"},\n    },\n  }\n}\n\nfunction unescapeJPSegment(s: string): string {\n  return s.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/deepRequired\"\n\nconst deepRequired: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default deepRequired\nmodule.exports = deepRequired\n", "import type {FuncKeywordDefinition, SchemaCxt} from \"ajv\"\n\nconst sequences: Record<string, number | undefined> = {}\n\nexport type DynamicDefaultFunc = (args?: Record<string, any>) => () => any\n\nconst DEFAULTS: Record<string, DynamicDefaultFunc | undefined> = {\n  timestamp: () => () => Date.now(),\n  datetime: () => () => new Date().toISOString(),\n  date: () => () => new Date().toISOString().slice(0, 10),\n  time: () => () => new Date().toISOString().slice(11),\n  random: () => () => Math.random(),\n  randomint: (args?: {max?: number}) => {\n    const max = args?.max ?? 2\n    return () => Math.floor(Math.random() * max)\n  },\n  seq: (args?: {name?: string}) => {\n    const name = args?.name ?? \"\"\n    sequences[name] ||= 0\n    return () => (sequences[name] as number)++\n  },\n}\n\ninterface PropertyDefaultSchema {\n  func: string\n  args: Record<string, any>\n}\n\ntype DefaultSchema = Record<string, string | PropertyDefaultSchema | undefined>\n\nconst getDef: (() => FuncKeywordDefinition) & {\n  DEFAULTS: typeof DEFAULTS\n} = Object.assign(_getDef, {DEFAULTS})\n\nfunction _getDef(): FuncKeywordDefinition {\n  return {\n    keyword: \"dynamicDefaults\",\n    type: \"object\",\n    schemaType: [\"string\", \"object\"],\n    modifying: true,\n    valid: true,\n    compile(schema: DefaultSchema, _parentSchema, it: SchemaCxt) {\n      if (!it.opts.useDefaults || it.compositeRule) return () => true\n      const fs: Record<string, () => any> = {}\n      for (const key in schema) fs[key] = getDefault(schema[key])\n      const empty = it.opts.useDefaults === \"empty\"\n\n      return (data: Record<string, any>) => {\n        for (const prop in schema) {\n          if (data[prop] === undefined || (empty && (data[prop] === null || data[prop] === \"\"))) {\n            data[prop] = fs[prop]()\n          }\n        }\n        return true\n      }\n    },\n    metaSchema: {\n      type: \"object\",\n      additionalProperties: {\n        anyOf: [\n          {type: \"string\"},\n          {\n            type: \"object\",\n            additionalProperties: false,\n            required: [\"func\", \"args\"],\n            properties: {\n              func: {type: \"string\"},\n              args: {type: \"object\"},\n            },\n          },\n        ],\n      },\n    },\n  }\n}\n\nfunction getDefault(d: string | PropertyDefaultSchema | undefined): () => any {\n  return typeof d == \"object\" ? getObjDefault(d) : getStrDefault(d)\n}\n\nfunction getObjDefault({func, args}: PropertyDefaultSchema): () => any {\n  const def = DEFAULTS[func]\n  assertDefined(func, def)\n  return def(args)\n}\n\nfunction getStrDefault(d = \"\"): () => any {\n  const def = DEFAULTS[d]\n  assertDefined(d, def)\n  return def()\n}\n\nfunction assertDefined(name: string, def?: DynamicDefaultFunc): asserts def is DynamicDefaultFunc {\n  if (!def) throw new Error(`invalid \"dynamicDefaults\" keyword property value: ${name}`)\n}\n\nexport default getDef\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDef from \"../definitions/dynamicDefaults\"\n\nconst dynamicDefaults: Plugin<undefined> = (ajv) => ajv.addKeyword(getDef())\n\nexport default dynamicDefaults\nmodule.exports = dynamicDefaults\n", "import type {KeywordDefinition, KeywordErrorDefinition, KeywordCxt, ErrorObject} from \"ajv\"\nimport {_, str, nil, Name} from \"ajv/dist/compile/codegen\"\nimport type {DefinitionOptions} from \"./_types\"\nimport {metaSchemaRef} from \"./_util\"\n\nexport type SelectError = ErrorObject<\"select\", {failingCase?: string; failingDefault?: true}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {schemaProp}}) =>\n    schemaProp\n      ? str`should match case \"${schemaProp}\" schema`\n      : str`should match default case schema`,\n  params: ({params: {schemaProp}}) =>\n    schemaProp ? _`{failingCase: ${schemaProp}}` : _`{failingDefault: true}`,\n}\n\nexport default function getDef(opts?: DefinitionOptions): KeywordDefinition[] {\n  const metaSchema = metaSchemaRef(opts)\n\n  return [\n    {\n      keyword: \"select\",\n      schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n      $data: true,\n      error,\n      dependencies: [\"selectCases\"],\n      code(cxt: KeywordCxt) {\n        const {gen, schemaCode, parentSchema} = cxt\n        cxt.block$data(nil, () => {\n          const valid = gen.let(\"valid\", true)\n          const schValid = gen.name(\"_valid\")\n          const value = gen.const(\"value\", _`${schemaCode} === null ? \"null\" : ${schemaCode}`)\n          gen.if(false) // optimizer should remove it from generated code\n          for (const schemaProp in parentSchema.selectCases) {\n            cxt.setParams({schemaProp})\n            gen.elseIf(_`\"\" + ${value} == ${schemaProp}`) // intentional ==, to match numbers and booleans\n            const schCxt = cxt.subschema({keyword: \"selectCases\", schemaProp}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.else()\n          if (parentSchema.selectDefault !== undefined) {\n            cxt.setParams({schemaProp: undefined})\n            const schCxt = cxt.subschema({keyword: \"selectDefault\"}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.endIf()\n          cxt.pass(valid)\n        })\n      },\n    },\n    {\n      keyword: \"selectCases\",\n      dependencies: [\"select\"],\n      metaSchema: {\n        type: \"object\",\n        additionalProperties: metaSchema,\n      },\n    },\n    {\n      keyword: \"selectDefault\",\n      dependencies: [\"select\", \"selectCases\"],\n      metaSchema,\n    },\n  ]\n}\n\nmodule.exports = getDef\n", "import type {Plugin} from \"ajv\"\nimport getDefs from \"../definitions/select\"\nimport type {DefinitionOptions} from \"../definitions/_types\"\n\nconst select: Plugin<DefinitionOptions> = (ajv, opts?: DefinitionOptions) => {\n  getDefs(opts).forEach((d) => ajv.addKeyword(d))\n  return ajv\n}\n\nexport default select\nmodule.exports = select\n", "import type {Plugin} from \"ajv\"\nimport typeofPlugin from \"./typeof\"\nimport instanceofPlugin from \"./instanceof\"\nimport range from \"./range\"\nimport exclusiveRange from \"./exclusiveRange\"\nimport regexp from \"./regexp\"\nimport transform from \"./transform\"\nimport uniqueItemProperties from \"./uniqueItemProperties\"\nimport allRequired from \"./allRequired\"\nimport anyRequired from \"./anyRequired\"\nimport oneRequired from \"./oneRequired\"\nimport patternRequired from \"./patternRequired\"\nimport prohibited from \"./prohibited\"\nimport deepProperties from \"./deepProperties\"\nimport deepRequired from \"./deepRequired\"\nimport dynamicDefaults from \"./dynamicDefaults\"\nimport select from \"./select\"\n\n// TODO type\nconst ajvKeywords: Record<string, Plugin<any> | undefined> = {\n  typeof: typeofPlugin,\n  instanceof: instanceofPlugin,\n  range,\n  exclusiveRange,\n  regexp,\n  transform,\n  uniqueItemProperties,\n  allRequired,\n  anyRequired,\n  oneRequired,\n  patternRequired,\n  prohibited,\n  deepProperties,\n  deepRequired,\n  dynamicDefaults,\n  select,\n}\n\nexport default ajvKeywords\nmodule.exports = ajvKeywords\n", "import type Ajv from \"ajv\"\nimport type {Plugin} from \"ajv\"\nimport plugins from \"./keywords\"\n\nexport {AjvKeywordsError} from \"./definitions\"\n\nconst ajvKeywords: Plugin<string | string[]> = (ajv: Ajv, keyword?: string | string[]): Ajv => {\n  if (Array.isArray(keyword)) {\n    for (const k of keyword) get(k)(ajv)\n    return ajv\n  }\n  if (keyword) {\n    get(keyword)(ajv)\n    return ajv\n  }\n  for (keyword in plugins) get(keyword)(ajv)\n  return ajv\n}\n\najvKeywords.get = get\n\nfunction get(keyword: string): Plugin<any> {\n  const defFunc = plugins[keyword]\n  if (!defFunc) throw new Error(\"Unknown keyword \" + keyword)\n  return defFunc\n}\n\nexport default ajvKeywords\nmodule.exports = ajvKeywords\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nmodule.exports.default = ajvKeywords\n", "import type {Format, FormatDefinition} from \"ajv\"\nimport type {FormatValidator, FormatCompare} from \"ajv/dist/types\"\n\nexport type FormatMode = \"fast\" | \"full\"\n\nexport type FormatName =\n  | \"date\"\n  | \"time\"\n  | \"date-time\"\n  | \"duration\"\n  | \"uri\"\n  | \"uri-reference\"\n  | \"uri-template\"\n  | \"url\"\n  | \"email\"\n  | \"hostname\"\n  | \"ipv4\"\n  | \"ipv6\"\n  | \"regex\"\n  | \"uuid\"\n  | \"json-pointer\"\n  | \"json-pointer-uri-fragment\"\n  | \"relative-json-pointer\"\n  | \"byte\"\n  | \"int32\"\n  | \"int64\"\n  | \"float\"\n  | \"double\"\n  | \"password\"\n  | \"binary\"\n\nexport type DefinedFormats = {\n  [key in FormatName]: Format\n}\n\nfunction fmtDef(\n  validate: RegExp | FormatValidator<string>,\n  compare: FormatCompare<string>\n): FormatDefinition<string> {\n  return {validate, compare}\n}\n\nexport const fullFormats: DefinedFormats = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: fmtDef(date, compareDate),\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: fmtDef(time, compareTime),\n  \"date-time\": fmtDef(date_time, compareDateTime),\n  // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n  duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n  uri,\n  \"uri-reference\":\n    /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  \"uri-template\":\n    /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  email:\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname:\n    /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n  regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n  \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n  // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n  // byte: https://github.com/miguelmota/is-base64\n  byte,\n  // signed 32 bit integer\n  int32: {type: \"number\", validate: validateInt32},\n  // signed 64 bit integer\n  int64: {type: \"number\", validate: validateInt64},\n  // C-type float\n  float: {type: \"number\", validate: validateNumber},\n  // C-type double\n  double: {type: \"number\", validate: validateNumber},\n  // hint to the UI to hide input strings\n  password: true,\n  // unchecked string payload\n  binary: true,\n}\n\nexport const fastFormats: DefinedFormats = {\n  ...fullFormats,\n  date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n  time: fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareTime\n  ),\n  \"date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareDateTime\n  ),\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n  email:\n    /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n}\n\nexport const formatNames = Object.keys(fullFormats) as FormatName[]\n\nfunction isLeapYear(year: number): boolean {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  const matches: string[] | null = DATE.exec(str)\n  if (!matches) return false\n  const year: number = +matches[1]\n  const month: number = +matches[2]\n  const day: number = +matches[3]\n  return (\n    month >= 1 &&\n    month <= 12 &&\n    day >= 1 &&\n    day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n  )\n}\n\nfunction compareDate(d1: string, d2: string): number | undefined {\n  if (!(d1 && d2)) return undefined\n  if (d1 > d2) return 1\n  if (d1 < d2) return -1\n  return 0\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i\n\nfunction time(str: string, withTimeZone?: boolean): boolean {\n  const matches: string[] | null = TIME.exec(str)\n  if (!matches) return false\n\n  const hour: number = +matches[1]\n  const minute: number = +matches[2]\n  const second: number = +matches[3]\n  const timeZone: string = matches[5]\n  return (\n    ((hour <= 23 && minute <= 59 && second <= 59) ||\n      (hour === 23 && minute === 59 && second === 60)) &&\n    (!withTimeZone || timeZone !== \"\")\n  )\n}\n\nfunction compareTime(t1: string, t2: string): number | undefined {\n  if (!(t1 && t2)) return undefined\n  const a1 = TIME.exec(t1)\n  const a2 = TIME.exec(t2)\n  if (!(a1 && a2)) return undefined\n  t1 = a1[1] + a1[2] + a1[3] + (a1[4] || \"\")\n  t2 = a2[1] + a2[2] + a2[3] + (a2[4] || \"\")\n  if (t1 > t2) return 1\n  if (t1 < t2) return -1\n  return 0\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction date_time(str: string): boolean {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  const dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n  return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true)\n}\n\nfunction compareDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)\n  const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)\n  const res = compareDate(d1, d2)\n  if (res === undefined) return undefined\n  return res || compareTime(t1, t2)\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n  /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n  BYTE.lastIndex = 0\n  return BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n  // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n  return Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n  return true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n  if (Z_ANCHOR.test(str)) return false\n  try {\n    new RegExp(str)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n", "import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n", "import {\n  DefinedFormats,\n  FormatMode,\n  FormatName,\n  formatNames,\n  fastFormats,\n  fullFormats,\n} from \"./formats\"\nimport formatLimit from \"./limit\"\nimport type Ajv from \"ajv\"\nimport type {Plugin, Format} from \"ajv\"\nimport {_, Name} from \"ajv/dist/compile/codegen\"\n\nexport {FormatMode, FormatName} from \"./formats\"\nexport {LimitFormatError} from \"./limit\"\nexport interface FormatOptions {\n  mode?: FormatMode\n  formats?: FormatName[]\n  keywords?: boolean\n}\n\nexport type FormatsPluginOptions = FormatName[] | FormatOptions\n\nexport interface FormatsPlugin extends Plugin<FormatsPluginOptions> {\n  get: (format: FormatName, mode?: FormatMode) => Format\n}\n\nconst fullName = new Name(\"fullFormats\")\nconst fastName = new Name(\"fastFormats\")\n\nconst formatsPlugin: FormatsPlugin = (\n  ajv: Ajv,\n  opts: FormatsPluginOptions = {keywords: true}\n): Ajv => {\n  if (Array.isArray(opts)) {\n    addFormats(ajv, opts, fullFormats, fullName)\n    return ajv\n  }\n  const [formats, exportName] =\n    opts.mode === \"fast\" ? [fastFormats, fastName] : [fullFormats, fullName]\n  const list = opts.formats || formatNames\n  addFormats(ajv, list, formats, exportName)\n  if (opts.keywords) formatLimit(ajv)\n  return ajv\n}\n\nformatsPlugin.get = (name: FormatName, mode: FormatMode = \"full\"): Format => {\n  const formats = mode === \"fast\" ? fastFormats : fullFormats\n  const f = formats[name]\n  if (!f) throw new Error(`Unknown format \"${name}\"`)\n  return f\n}\n\nfunction addFormats(ajv: Ajv, list: FormatName[], fs: DefinedFormats, exportName: Name): void {\n  ajv.opts.code.formats ??= _`require(\"ajv-formats/dist/formats\").${exportName}`\n  for (const f of list) ajv.addFormat(f, fs[f])\n}\n\nmodule.exports = exports = formatsPlugin\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default formatsPlugin\n", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/** @typedef {import(\"ajv\").default} Ajv */\n/** @typedef {import(\"ajv\").SchemaValidateFunction} SchemaValidateFunction */\n/** @typedef {import(\"ajv\").AnySchemaObject} AnySchemaObject */\n/** @typedef {import(\"../validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/**\n * @param {string} message\n * @param {object} schema\n * @param {string} data\n * @returns {SchemaUtilErrorObject}\n */\nfunction errorMessage(message, schema, data) {\n  return {\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    dataPath: undefined,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    schemaPath: undefined,\n    keyword: \"absolutePath\",\n    params: {\n      absolutePath: data\n    },\n    message,\n    parentSchema: schema\n  };\n}\n\n/**\n * @param {boolean} shouldBeAbsolute\n * @param {object} schema\n * @param {string} data\n * @returns {SchemaUtilErrorObject}\n */\nfunction getErrorFor(shouldBeAbsolute, schema, data) {\n  const message = shouldBeAbsolute ? `The provided value ${JSON.stringify(data)} is not an absolute path!` : `A relative path is expected. However, the provided value ${JSON.stringify(data)} is an absolute path!`;\n  return errorMessage(message, schema, data);\n}\n\n/**\n *\n * @param {Ajv} ajv\n * @returns {Ajv}\n */\nfunction addAbsolutePathKeyword(ajv) {\n  ajv.addKeyword({\n    keyword: \"absolutePath\",\n    type: \"string\",\n    errors: true,\n    /**\n     * @param {boolean} schema\n     * @param {AnySchemaObject} parentSchema\n     * @returns {SchemaValidateFunction}\n     */\n    compile(schema, parentSchema) {\n      /** @type {SchemaValidateFunction} */\n      const callback = data => {\n        let passes = true;\n        const isExclamationMarkPresent = data.includes(\"!\");\n        if (isExclamationMarkPresent) {\n          callback.errors = [errorMessage(`The provided value ${JSON.stringify(data)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`, parentSchema, data)];\n          passes = false;\n        }\n\n        // ?:[A-Za-z]:\\\\ - Windows absolute path\n        // \\\\\\\\ - Windows network absolute path\n        // \\/ - Unix-like OS absolute path\n        const isCorrectAbsolutePath = schema === /^(?:[A-Za-z]:(\\\\|\\/)|\\\\\\\\|\\/)/.test(data);\n        if (!isCorrectAbsolutePath) {\n          callback.errors = [getErrorFor(schema, parentSchema, data)];\n          passes = false;\n        }\n        return passes;\n      };\n      callback.errors = [];\n      return callback;\n    }\n  });\n  return ajv;\n}\nvar _default = addAbsolutePathKeyword;\nexports.default = _default;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/** @typedef {import(\"ajv\").default} Ajv */\n/** @typedef {import(\"ajv\").SchemaValidateFunction} SchemaValidateFunction */\n/** @typedef {import(\"ajv\").AnySchemaObject} AnySchemaObject */\n/** @typedef {import(\"ajv\").ValidateFunction} ValidateFunction */\n\n/**\n *\n * @param {Ajv} ajv\n * @returns {Ajv}\n */\nfunction addUndefinedAsNullKeyword(ajv) {\n  ajv.addKeyword({\n    keyword: \"undefinedAsNull\",\n    before: \"enum\",\n    modifying: true,\n    /** @type {SchemaValidateFunction} */\n    validate(kwVal, data, metadata, dataCxt) {\n      if (kwVal && dataCxt && metadata && typeof metadata.enum !== \"undefined\") {\n        const idx = dataCxt.parentDataProperty;\n        if (typeof dataCxt.parentData[idx] === \"undefined\") {\n          // eslint-disable-next-line no-param-reassign\n          dataCxt.parentData[dataCxt.parentDataProperty] = null;\n        }\n      }\n      return true;\n    }\n  });\n  return ajv;\n}\nvar _default = addUndefinedAsNullKeyword;\nexports.default = _default;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationError\", {\n  enumerable: true,\n  get: function () {\n    return _ValidationError.default;\n  }\n});\nexports.disableValidation = disableValidation;\nexports.enableValidation = enableValidation;\nexports.needValidate = needValidate;\nexports.validate = validate;\nvar _ValidationError = _interopRequireDefault(require(\"./ValidationError\"));\nvar _memorize = _interopRequireDefault(require(\"./util/memorize\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst getAjv = (0, _memorize.default)(() => {\n  // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).\n  // eslint-disable-next-line global-require\n  const Ajv = require(\"ajv\").default;\n  // eslint-disable-next-line global-require\n  const ajvKeywords = require(\"ajv-keywords\").default;\n  // eslint-disable-next-line global-require\n  const addFormats = require(\"ajv-formats\").default;\n\n  /**\n   * @type {Ajv}\n   */\n  const ajv = new Ajv({\n    strict: false,\n    allErrors: true,\n    verbose: true,\n    $data: true\n  });\n  ajvKeywords(ajv, [\"instanceof\", \"patternRequired\"]);\n  addFormats(ajv, {\n    keywords: true\n  });\n\n  // Custom keywords\n  // eslint-disable-next-line global-require\n  const addAbsolutePathKeyword = require(\"./keywords/absolutePath\").default;\n  addAbsolutePathKeyword(ajv);\n  const addUndefinedAsNullKeyword =\n  // eslint-disable-next-line global-require\n  require(\"./keywords/undefinedAsNull\").default;\n  addUndefinedAsNullKeyword(ajv);\n  return ajv;\n});\n\n/** @typedef {import(\"json-schema\").JSONSchema4} JSONSchema4 */\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n/** @typedef {import(\"ajv\").ErrorObject} ErrorObject */\n\n/**\n * @typedef {Object} Extend\n * @property {string=} formatMinimum\n * @property {string=} formatMaximum\n * @property {string=} formatExclusiveMinimum\n * @property {string=} formatExclusiveMaximum\n * @property {string=} link\n * @property {boolean=} undefinedAsNull\n */\n\n/** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend} Schema */\n\n/** @typedef {ErrorObject & { children?: Array<ErrorObject> }} SchemaUtilErrorObject */\n\n/**\n * @callback PostFormatter\n * @param {string} formattedError\n * @param {SchemaUtilErrorObject} error\n * @returns {string}\n */\n\n/**\n * @typedef {Object} ValidationErrorConfiguration\n * @property {string=} name\n * @property {string=} baseDataPath\n * @property {PostFormatter=} postFormatter\n */\n\n/**\n * @param {SchemaUtilErrorObject} error\n * @param {number} idx\n * @returns {SchemaUtilErrorObject}\n */\nfunction applyPrefix(error, idx) {\n  // eslint-disable-next-line no-param-reassign\n  error.instancePath = `[${idx}]${error.instancePath}`;\n  if (error.children) {\n    error.children.forEach(err => applyPrefix(err, idx));\n  }\n  return error;\n}\nlet skipValidation = false;\n\n// We use `process.env.SKIP_VALIDATION` because you can have multiple `schema-utils` with different version,\n// so we want to disable it globally, `process.env` doesn't supported by browsers, so we have the local `skipValidation` variables\n\n// Enable validation\nfunction enableValidation() {\n  skipValidation = false;\n\n  // Disable validation for any versions\n  if (process && process.env) {\n    process.env.SKIP_VALIDATION = \"n\";\n  }\n}\n\n// Disable validation\nfunction disableValidation() {\n  skipValidation = true;\n  if (process && process.env) {\n    process.env.SKIP_VALIDATION = \"y\";\n  }\n}\n\n// Check if we need to confirm\nfunction needValidate() {\n  if (skipValidation) {\n    return false;\n  }\n  if (process && process.env && process.env.SKIP_VALIDATION) {\n    const value = process.env.SKIP_VALIDATION.trim();\n    if (/^(?:y|yes|true|1|on)$/i.test(value)) {\n      return false;\n    }\n    if (/^(?:n|no|false|0|off)$/i.test(value)) {\n      return true;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Schema} schema\n * @param {Array<object> | object} options\n * @param {ValidationErrorConfiguration=} configuration\n * @returns {void}\n */\nfunction validate(schema, options, configuration) {\n  if (!needValidate()) {\n    return;\n  }\n  let errors = [];\n  if (Array.isArray(options)) {\n    for (let i = 0; i <= options.length - 1; i++) {\n      errors.push(...validateObject(schema, options[i]).map(err => applyPrefix(err, i)));\n    }\n  } else {\n    errors = validateObject(schema, options);\n  }\n  if (errors.length > 0) {\n    throw new _ValidationError.default(errors, schema, configuration);\n  }\n}\n\n/**\n * @param {Schema} schema\n * @param {Array<object> | object} options\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction validateObject(schema, options) {\n  // Not need to cache, because `ajv@8` has built-in cache\n  const compiledSchema = getAjv().compile(schema);\n  const valid = compiledSchema(options);\n  if (valid) return [];\n  return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];\n}\n\n/**\n * @param {Array<ErrorObject>} errors\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterErrors(errors) {\n  /** @type {Array<SchemaUtilErrorObject>} */\n  let newErrors = [];\n  for (const error of /** @type {Array<SchemaUtilErrorObject>} */errors) {\n    const {\n      instancePath\n    } = error;\n    /** @type {Array<SchemaUtilErrorObject>} */\n    let children = [];\n    newErrors = newErrors.filter(oldError => {\n      if (oldError.instancePath.includes(instancePath)) {\n        if (oldError.children) {\n          children = children.concat(oldError.children.slice(0));\n        }\n\n        // eslint-disable-next-line no-undefined, no-param-reassign\n        oldError.children = undefined;\n        children.push(oldError);\n        return false;\n      }\n      return true;\n    });\n    if (children.length) {\n      error.children = children;\n    }\n    newErrors.push(error);\n  }\n  return newErrors;\n}", "\"use strict\";\n\nconst {\n  validate,\n  ValidationError,\n  enableValidation,\n  disableValidation,\n  needValidate\n} = require(\"./validate\");\nmodule.exports = {\n  validate,\n  ValidationError,\n  enableValidation,\n  disableValidation,\n  needValidate\n};", "var { validate } = require('schema-utils');\n\nfunction validateOptions(options, schema) {\n  validate(schema, options);\n}\n\nfunction processOptions(options, processors) {\n  const processedOptions = {};\n    \n  for (const [property, processor] of Object.entries(processors)) {\n    processedOptions[property] = options[property];\n    if (processedOptions[property] === undefined) {\n      processedOptions[property] = processor.default;\n    }\n    if (processor.process) {\n      processedOptions[property] = processor.process(processedOptions[property]);\n    }\n  }\n\n  return processedOptions;\n}\n\nmodule.exports = {\n  validateOptions,\n  processOptions,\n};\n", "module.exports = {\n  type: 'object',\n  properties: {\n    filerDir: {\n      type: 'string',\n    },\n    shimsDir: {\n      type: 'string',\n    },\n    shimFs: {\n      type: 'boolean',\n    },\n    shimPath: {\n      type: 'boolean',\n    },\n    fsProvider: {\n      type: 'string',\n    },\n    fsProviderDir: {\n      type: 'string',\n    },\n  }\n};\n", "var path = require('path');\n\nconst ROOT_DIR_TAG = '<rootDir>';\nconst CWD = process.cwd();\n\nmodule.exports = {\n  filerDir: {\n    process: function(value) {\n      if (!value) {\n        return path.join(CWD, 'node_modules', 'filer');\n      }\n      return path.resolve(value.replace(ROOT_DIR_TAG, CWD));\n    },\n  },\n  shimsDir: {\n    process: function(value) {\n      if (!value) {\n        return path.join(CWD, 'node_modules', 'filer', 'shims');\n      }\n      return path.resolve(value.replace(ROOT_DIR_TAG, CWD));\n    }\n  },\n  fsProviderDir: {\n    process: function(value) {\n      if (!value) {\n        return path.join(CWD, 'node_modules', 'filer', 'shims', 'providers');\n      }\n      return path.resolve(value.replace(ROOT_DIR_TAG, CWD));\n    },\n  },\n  shimFs: { default: true },\n  shimPath: { default: true},\n  fsProvider: { default: 'default'},\n};\n", "var path = require('path');\nvar utils = require('./utils');\n\nconst PLUGIN_NAME = 'filer-webpack-plugin';\n\nconst OPTIONS_SCHEMA = require('./schema');\nconst OPTIONS_PROCESSORS = require('./processors');\n\nmodule.exports = class FilerWebpackPlugin {\n\n  constructor(options = {}) {\n    utils.validateOptions(options, OPTIONS_SCHEMA);\n    this.options = utils.processOptions(options, OPTIONS_PROCESSORS);\n  }\n\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\n      PLUGIN_NAME,\n      (factory) => {\n        factory.hooks.resolve.tap(\n          PLUGIN_NAME,\n          (resolveData) => {\n            // Resolve fsProvider if required\n            if (\n              resolveData.request === 'fsProvider'\n              && resolveData.context === this.options.shimsDir\n            ) {\n              return this.resolveFsProvider(resolveData);\n            }\n\n            // Ignore filer files (these should resolve modules normally)\n            if (resolveData.context.startsWith(this.options.filerDir)) return;\n\n            // Apply fs, path and buffer shims if required\n            switch (resolveData.request) {\n            case 'fs':\n              if (!this.options.shimFs) return;\n              return this.applyFsShim(resolveData);\n            case 'path':\n              if (!this.options.shimPath) return;\n              return this.applyPathShim(resolveData);\n            default:\n              return;\n            }\n          }\n        );\n      },\n    );\n  }\n\n  resolveFsProvider(resolveData) {\n    switch (this.options.fsProvider) {\n    case 'default':\n      resolveData.request = path.join(this.options.fsProviderDir, 'default.js');\n      break;\n    case 'indexeddb':\n      resolveData.request = path.join(this.options.fsProviderDir, 'indexeddb.js');\n      break;\n    case 'memory':\n      resolveData.request = path.join(this.options.fsProviderDir, 'memory.js');\n      break;\n    case 'custom':\n      resolveData.request = path.join(this.options.fsProviderDir, 'custom.js');\n      break;\n    default:\n      throw new Error([\n        'Invalid option for fsProvider.',\n        'fsProvider must be one of \\'default\\', \\'indexeddb\\', \\'memory\\' or \\'custom\\'.',\n        'If using a custom fsProvider, you must also provide the fsProviderDir option.'\n      ].join(' '));\n    }\n  }\n\n  applyFsShim(resolveData) {\n    resolveData.request = path.join(this.options.shimsDir, 'fs.js');\n  }\n    \n  applyPathShim(resolveData) {\n    resolveData.request = path.join(this.options.shimsDir, 'path.js');\n  }\n};\n", "let fs = null;\nlet Filer = null;\n\nmodule.exports = Filer = {\n  FileSystem: require('./filesystem/interface.js'),\n  Buffer: Buffer,\n  // We previously called this Path, but node calls it path. Do both\n  Path: require('./path.js'),\n  path: require('./path.js'),\n  Errors: require('./errors.js'),\n  Shell: require('./shell/shell.js'),\n  /**\n   * @deprecated Importing filer from your webpack config is not recommended.\n   * \n   * The filer `FilerWebpackPlugin` class is exposed directly. \n   * \n   * ```\n   * const { FilerWebpackPlugin } = require('filer/webpack');\n   * ```\n   */\n  FilerWebpackPlugin: require('./webpack-plugin'),\n};\n\n// Add a getter for the `fs` instance, which returns\n// a Filer FileSystem instance, using the default provider/flags.\nObject.defineProperty(Filer, 'fs', {\n  enumerable: true,\n  get() {\n    if(!fs) {\n      fs = new Filer.FileSystem();\n    }\n    return fs;\n  }\n});\n"],
  "mappings": "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",
  "names": ["require_promisify", "__commonJSMin", "exports", "promisify", "customArgumentsToken", "a", "b", "c", "d", "e", "f", "g", "require_isBufferBrowser", "__commonJSMin", "exports", "module", "arg", "require_inherits_browser", "__commonJSMin", "exports", "module", "ctor", "superCtor", "TempCtor", "require_util", "__commonJSMin", "exports", "formatRegExp", "f", "isString", "objects", "i", "inspect", "args", "len", "str", "x", "isNull", "isObject", "fn", "msg", "isUndefined", "warned", "deprecated", "debugs", "debugEnviron", "set", "pid", "obj", "opts", "ctx", "stylizeNoColor", "isBoolean", "stylizeWithColor", "formatValue", "styleType", "style", "arrayToHash", "array", "hash", "val", "idx", "value", "recurseTimes", "isFunction", "ret", "primitive", "formatPrimitive", "keys", "visibleKeys", "isError", "formatError", "name", "isRegExp", "isDate", "base", "braces", "isArray", "n", "output", "formatArray", "key", "formatProperty", "reduceToSingleString", "simple", "isNumber", "l", "hasOwnProperty", "desc", "line", "numLinesEst", "length", "prev", "cur", "ar", "arg", "isNullOrUndefined", "isSymbol", "re", "objectToString", "d", "e", "isPrimitive", "o", "pad", "months", "timestamp", "time", "origin", "add", "prop", "require_path", "__commonJSMin", "exports", "module", "isWindows", "util", "normalizeArray", "parts", "allowAboveRoot", "res", "i", "p", "trimArray", "arr", "lastIndex", "start", "end", "splitDeviceRe", "splitTailRe", "win32", "win32SplitPath", "filename", "result", "device", "tail", "result2", "dir", "basename", "ext", "win32StatPath", "path", "isUnc", "normalizeUNCRoot", "resolvedDevice", "resolvedTail", "resolvedAbsolute", "isAbsolute", "trailingSlash", "paths", "arg", "joined", "from", "to", "lowerFrom", "lowerTo", "toParts", "lowerFromParts", "lowerToParts", "length", "samePartsLength", "outputParts", "resolvedPath", "root", "f", "pathObject", "base", "pathString", "allParts", "splitPathRe", "posix", "posixSplitPath", "segment", "fromParts", "require_path", "__commonJSMin", "exports", "module", "nodePath", "filerPath", "path", "ext", "basename", "require_constants", "__commonJSMin", "exports", "module", "O_READ", "O_WRITE", "O_CREATE", "O_EXCLUSIVE", "O_TRUNCATE", "O_APPEND", "XATTR_CREATE", "XATTR_REPLACE", "require_indexeddb", "__commonJSMin", "exports", "module", "FILE_SYSTEM_NAME", "FILE_STORE_NAME", "IDB_RW", "IDB_RO", "IndexedDBContext", "db", "mode", "transaction", "callback", "objectStore", "request", "event", "err", "key", "result", "arrayBuffer", "value", "uint8BackedBuffer", "buf", "IndexedDB", "name", "indexedDB", "that", "openRequest", "require_async", "__commonJSMin", "exports", "module", "async", "fn", "arr", "iterator", "callback", "completed", "iterate", "err", "require_memory", "__commonJSMin", "exports", "module", "FILE_SYSTEM_NAME", "asyncCallback", "createDB", "pool", "name", "MemoryContext", "db", "readOnly", "callback", "objectStore", "key", "that", "value", "Memory", "require_providers", "__commonJSMin", "exports", "module", "IndexedDB", "Memory", "require_errors", "__commonJSMin", "exports", "module", "errors", "e", "errno", "errName", "defaultMessage", "FilerError", "msg", "path", "pathInfo", "require_environment", "__commonJSMin", "exports", "module", "defaults", "env", "name", "value", "require_balanced_match", "__commonJSMin", "exports", "module", "balanced", "a", "b", "str", "maybeMatch", "r", "range", "reg", "m", "begs", "beg", "left", "right", "result", "ai", "bi", "i", "require_brace_expansion", "__commonJSMin", "exports", "module", "balanced", "expandTop", "escSlash", "escOpen", "escClose", "escComma", "escPeriod", "numeric", "str", "escapeBraces", "unescapeBraces", "parseCommaParts", "parts", "m", "pre", "body", "post", "p", "postParts", "expand", "embrace", "isPadded", "el", "lte", "i", "y", "gte", "isTop", "expansions", "k", "expansion", "isNumericSequence", "isAlphaSequence", "isSequence", "isOptions", "n", "N", "x", "width", "incr", "test", "reverse", "pad", "c", "need", "z", "j", "MAX_PATTERN_LENGTH", "assertValidPattern", "pattern", "exports", "posixClasses", "braceEscape", "s", "regexpEscape", "rangesToString", "ranges", "parseClass", "glob", "position", "pos", "negs", "i", "sawStart", "uflag", "escaping", "negate", "endPos", "rangeStart", "WHILE", "c", "cls", "unip", "u", "neg", "r", "sranges", "snegs", "exports", "unescape", "s", "windowsPathsNoEscape", "exports", "brace_expressions_js_1", "unescape_js_1", "types", "isExtglobType", "c", "startNoTraversal", "startNoDot", "addPatternStart", "justDots", "reSpecials", "regExpEscape", "s", "qmark", "star", "starNoEmpty", "AST", "_AST", "#root", "#hasMagic", "#uflag", "#parts", "#parent", "#parentIndex", "#negs", "#filledNegs", "#options", "#toString", "#emptyExt", "type", "parent", "options", "p", "#fillNegs", "n", "pp", "part", "parts", "ret", "i", "pl", "#parseAST", "str", "ast", "pos", "opt", "escaping", "inBrace", "braceStart", "braceNeg", "acc", "ext", "pattern", "glob", "re", "body", "hasMagic", "uflag", "flags", "allowDot", "dot", "noEmpty", "src", "_", "#parseGlob", "start", "aps", "needNoTrav", "needNoDot", "end", "repeated", "#partsToRegExp", "bodyDotAllowed", "final", "close", "_hasMagic", "needUflag", "consumed", "magic", "exports", "escape", "s", "windowsPathsNoEscape", "exports", "brace_expansion_1", "__importDefault", "assert_valid_pattern_js_1", "ast_js_1", "escape_js_1", "unescape_js_1", "minimatch", "p", "pattern", "options", "Minimatch", "exports", "starDotExtRE", "starDotExtTest", "ext", "f", "starDotExtTestDot", "starDotExtTestNocase", "starDotExtTestNocaseDot", "starDotStarRE", "starDotStarTest", "starDotStarTestDot", "dotStarRE", "dotStarTest", "starRE", "starTest", "starTestDot", "qmarksRE", "qmarksTestNocase", "$0", "noext", "qmarksTestNoExt", "qmarksTestNocaseDot", "qmarksTestNoExtDot", "qmarksTestDot", "qmarksTest", "len", "defaultPlatform", "path", "qmark", "star", "twoStarDot", "twoStarNoDot", "filter", "a", "b", "defaults", "def", "orig", "type", "parent", "s", "list", "braceExpand", "makeRe", "match", "mm", "globMagic", "regExpEscape", "part", "_", "args", "rawGlobParts", "set", "__", "isUNC", "isDrive", "ss", "i", "globParts", "j", "optimizationLevel", "parts", "gs", "prev", "didSomething", "dd", "gss", "next", "p2", "other", "splin", "matched", "emptyGSMatch", "ai", "bi", "result", "which", "negate", "negateOffset", "file", "partial", "fileDrive", "fileUNC", "patternDrive", "patternUNC", "fdi", "pdi", "fd", "pd", "fi", "pi", "fl", "pl", "fr", "pr", "swallowee", "hit", "m", "fastTest", "re", "twoStar", "flags", "pp", "open", "close", "ff", "filename", "ast_js_2", "escape_js_2", "unescape_js_2", "require_shell", "__commonJSMin", "exports", "module", "promisify", "Path", "Errors", "Environment", "async", "minimatch", "Shell", "fs", "options", "env", "cwd", "path", "callback", "err", "stats", "methodName", "args", "sh", "error", "data", "cmd", "e", "createFile", "updateTimes", "now", "atime", "mtime", "files", "all", "append", "item", "filename", "dir", "list", "pathname", "result", "entries", "getDirEntry", "name", "entry", "items", "remove", "tmp", "_mkdirp", "stat", "parent", "exec", "next", "found", "processPath", "maybeProcessPath", "rawPath", "walk", "require_eventemitter", "__commonJSMin", "exports", "module", "removeItem", "item", "array", "i", "EventEmitter", "space", "methods", "name", "fn", "args", "self", "pvt", "pub", "require_shared", "__commonJSMin", "exports", "module", "generateRandom", "template", "c", "v", "guid", "randomChars", "n", "nop", "require_intercom", "__commonJSMin", "exports", "module", "EventEmitter", "guid", "throttle", "delay", "fn", "last", "now", "extend", "a", "b", "key", "localStorage", "window", "Intercom", "self", "storageHandler", "TIMEOUT", "WAIT", "executed", "listening", "waitTimer", "lock", "activeLock", "INDEX_LOCK", "unlock", "threshold", "THRESHOLD_TTL_EMIT", "changed", "messages", "INDEX_EMIT", "i", "timestamp", "ttl", "table", "INDEX_ONCE", "THRESHOLD_TTL_ONCE", "event", "field", "currentValue", "data", "name", "message", "id", "packet", "delimiter", "intercom", "require_fs_watcher", "__commonJSMin", "exports", "module", "EventEmitter", "Path", "Intercom", "FSWatcher", "self", "recursive", "recursivePathPrefix", "filename", "onchange", "path", "filename_", "persistent_", "recursive_", "require_directory_entry", "__commonJSMin", "exports", "module", "NODE_TYPE_FILE", "id", "type", "require_open_files", "__commonJSMin", "exports", "module", "FIRST_DESCRIPTOR", "openFiles", "getEmptyDescriptor", "fd", "getOpenFileDescription", "ofd", "allocDescriptor", "openFileDescription", "releaseDescriptor", "require_node", "__commonJSMin", "exports", "module", "NODE_TYPE_FILE", "NODE_TYPE_DIRECTORY", "NODE_TYPE_SYMBOLIC_LINK", "DEFAULT_FILE_PERMISSIONS", "DEFAULT_DIR_PERMISSIONS", "S_IFREG", "S_IFDIR", "S_IFLNK", "ensureID", "options", "prop", "callback", "err", "id", "generateMode", "nodeType", "modePermissions", "Node", "now", "value", "require_open_file_description", "__commonJSMin", "exports", "module", "Errors", "Node", "OpenFileDescription", "path", "id", "flags", "position", "context", "callback", "check_if_node_exists", "error", "node", "require_super_node", "__commonJSMin", "exports", "module", "Constants", "SuperNode", "options", "now", "callback", "err", "rnode", "require_stats", "__commonJSMin", "exports", "module", "Constants", "Path", "dateFromMs", "ms", "Stats", "path", "fileNode", "devName", "require_dirent", "__commonJSMin", "exports", "module", "Stats", "Dirent", "path", "fileNode", "devName", "require_implementation", "__commonJSMin", "exports", "module", "Path", "normalize", "dirname", "basename", "isAbsolutePath", "shared", "async", "Constants", "NODE_TYPE_FILE", "NODE_TYPE_DIRECTORY", "NODE_TYPE_SYMBOLIC_LINK", "NODE_TYPE_META", "FULL_READ_WRITE_EXEC_PERMISSIONS", "ROOT_DIRECTORY_NAME", "SUPER_NODE_ID", "SYMLOOP_MAX", "O_READ", "O_WRITE", "O_CREATE", "O_EXCLUSIVE", "O_APPEND", "O_FLAGS", "XATTR_CREATE", "XATTR_REPLACE", "FS_NOMTIME", "FS_NOCTIME", "Errors", "DirectoryEntry", "openFiles", "OpenFileDescription", "SuperNode", "Node", "Dirent", "Stats", "update_node_times", "context", "path", "node", "times", "callback", "flags", "update", "complete", "error", "make_node", "type", "name", "parentPath", "parentNode", "parentNodeData", "create_node_in_parent", "parentDirectoryNode", "find_node", "check_if_node_exists", "result", "create_node", "update_parent_node_data", "update_time", "now", "followedCount", "read_root_directory_node", "nodeData", "superNode", "check_root_directory_node", "rootDirectoryNode", "read_parent_directory_data", "get_node_from_parent_directory_data", "parentDirectoryData", "nodeId", "data", "is_symbolic_link", "follow_symbolic_link", "set_extended_attribute", "value", "flag", "xattrs", "ensure_root_directory", "directoryNode", "directoryData", "ensure_super_node", "existingNode", "write_directory_node", "write_directory_data", "make_directory", "check_if_directory_exists", "update_parent_directory_data", "access_file", "mode", "F_OK", "R_OK", "W_OK", "X_OK", "S_IXUSR", "S_IXGRP", "S_IXOTH", "err", "st_mode", "validateAndMaskMode", "remove_directory", "check_if_node_is_directory", "check_if_directory_is_empty", "remove_directory_entry_from_parent_directory_node", "remove_directory_node", "remove_directory_data", "open_file", "directoryEntry", "fileNode", "fileData", "set_file_node", "read_directory_data", "check_if_file_exists", "check_if_symbolic_link", "write_file_node", "write_file_data", "update_directory_data", "handle_update_result", "replace_data", "ofd", "buffer", "offset", "length", "return_nbytes", "update_file_node", "newData", "write_data", "position", "update_file_data", "_position", "newSize", "read_file_data", "read_data", "handle_file_data", "stat_file", "fstat_file", "lstat_file", "link_node", "oldpath", "newpath", "oldname", "oldParentPath", "newname", "newParentPath", "ctime", "oldDirectoryNode", "oldDirectoryData", "newDirectoryNode", "newDirectoryData", "fileNodeID", "read_file_node", "check_if_new_file_exists", "read_new_directory_data", "check_if_old_file_exists", "read_old_directory_data", "unlink_node", "delete_file_data", "read_directory", "options", "validate_directory_options", "handle_directory_data", "files", "fileBuffers", "file", "fileBuffer", "to_dir_entry", "filename", "filepath", "get_dir_entry", "dirEnt", "dirEnts", "check_result", "stats", "enc", "make_symbolic_link", "srcpath", "dstpath", "read_link", "check_if_symbolic", "target", "truncate_file", "truncate_file_data", "ftruncate_file", "utimes_file", "atime", "mtime", "update_times", "futimes_file", "setxattr_file", "setxattr", "fsetxattr_file", "getxattr_file", "get_xattr", "fgetxattr_file", "removexattr_file", "remove_xattr", "fremovexattr_file", "validate_flags", "validate_file_options", "fileMode", "open", "openFileDescription", "fd", "close", "mknod", "mkdir", "access", "mkdtemp", "prefix", "random", "rmdir", "stat", "fstat", "link", "unlink", "read", "wrapped_cb", "bytesRead", "fsync", "validateInteger", "readFile", "cleanup", "fstatResult", "size", "write", "writeFile", "appendFile", "exists", "cb", "octalReg", "isUint32", "def", "parsed", "chmod_file", "update_mode", "fchmod_file", "chown_file", "uid", "gid", "update_owner", "fchown_file", "getxattr", "fgetxattr", "fsetxattr", "removexattr", "fremovexattr", "lseek", "whence", "update_descriptor_position", "readdir", "toUnixTimestamp", "time", "utimes", "currentTime", "futimes", "chmod", "fchmod", "chown", "fchown", "rename", "oldName", "newName", "oldParentDirectory", "oldParentData", "newParentDirectory", "newParentData", "read_new_directory", "update_old_parent_directory_data", "update_new_parent_directory_data", "check_if_new_directory_exists", "read_new_parent_directory_data", "get_new_parent_directory", "unlink_old_file", "check_node_type", "symlink", "readlink", "lstat", "truncate", "ftruncate", "require_interface", "__commonJSMin", "exports", "module", "promisify", "Path", "providers", "Shell", "Intercom", "FSWatcher", "Errors", "nop", "defaultGuidFn", "fsConstants", "FILE_SYSTEM_NAME", "FS_FORMAT", "FS_READY", "FS_PENDING", "FS_ERROR", "FS_NODUPEIDCHECK", "STDIN", "STDOUT", "STDERR", "impl", "maybeCallback", "callback", "err", "defaultCallback", "toPathIfFileURL", "fileURLOrPath", "pathname", "n", "third", "toPathIfBuffer", "bufferOrPath", "validatePath", "path", "allowRelative", "processPathArg", "args", "idx", "FileSystem", "options", "flags", "guid", "provider", "name", "forceFormatting", "fs", "queue", "operation", "error", "runQueued", "filename", "listener", "watcher", "wrappedGuidFn", "context", "guidWithCheck", "id", "value", "broadcastChanges", "changes", "intercom", "change", "complete", "wrappedContext", "methodName", "method", "shouldPromisify", "lastArgIndex", "missingCallback", "pathArg", "fnArgs", "require_memorize", "__commonJSMin", "exports", "memoize", "fn", "cache", "result", "_default", "require_Range", "__commonJSMin", "exports", "module", "Range", "_Range", "side", "exclusive", "value", "logic", "start", "end", "startExclusive", "endExclusive", "result", "values", "minMax", "j", "predicate", "i", "leftExclusive", "rightExclusive", "realStart", "realEnd", "require_hints", "__commonJSMin", "exports", "module", "Range", "schema", "logic", "hints", "type", "currentSchema", "tmpLength", "tmpFormat", "length", "range", "rangeFormat", "require_ValidationError", "__commonJSMin", "exports", "_memorize", "_interopRequireDefault", "obj", "SPECIFICITY", "isNumeric", "value", "filterMax", "array", "fn", "evaluatedMax", "max", "item", "filterChildren", "children", "newChildren", "error", "findAllChildren", "schemaPaths", "i", "predicate", "schemaPath", "refs", "extractRefs", "schema", "$ref", "s", "groupChildrenByFirstChild", "result", "child", "childrenStart", "indent", "str", "prefix", "hasNotInSchema", "findFirstTypedSchema", "canApplyNot", "typedSchema", "likeNumber", "likeInteger", "likeString", "likeNull", "likeBoolean", "isObject", "maybeObj", "likeArray", "likeObject", "getArticle", "type", "getSchemaNonTypes", "formatHints", "hints", "getUtilHints", "getHints", "logic", "ValidationError", "errors", "configuration", "headerNameFromSchema", "baseDataPathFromSchema", "splittedTitleFromSchema", "header", "path", "newPath", "schemaPart", "inner", "prevSchemas", "newLogic", "formatInnerSchema", "innerSchema", "addSelf", "needApplyLogicHere", "ifValue", "thenValue", "elseValue", "hasAdditionalItems", "items", "patternProperties", "pattern", "properties", "required", "objectStructure", "property", "isRequired", "dependencies", "propertyNames", "patternRequired", "dependencyName", "dependency", "dep", "additionalPath", "needDot", "schemaText", "keyword", "errorInstancePath", "splittedInstancePath", "defaultValue", "prettyInstancePath", "acc", "val", "instancePath", "parentSchema", "params", "format", "comparison", "limit", "multipleOf", "missingPattern", "length", "missingProperty", "hasProperty", "additionalProperty", "deps", "propertyName", "postfix", "schemaOutput", "lastChild", "remainingChildren", "filteredChildren", "nestedError", "failingKeyword", "message", "ErrorInJSON", "formattedError", "_default", "_CodeOrName", "exports", "Name", "s", "_Code", "code", "item", "_a", "c", "names", "_", "strs", "args", "i", "addCodeArg", "plus", "str", "expr", "safeStringify", "optimize", "arg", "interpolate", "res", "mergeExprItems", "a", "b", "strConcat", "c1", "c2", "x", "stringify", "getProperty", "key", "getEsmExportName", "regexpCode", "rx", "code_1", "ValueError", "name", "UsedValueState", "exports", "Scope", "prefixes", "parent", "nameOrPrefix", "prefix", "ng", "_b", "_a", "ValueScopeName", "nameStr", "value", "property", "itemIndex", "line", "ValueScope", "opts", "valueKey", "vs", "_name", "s", "keyOrRef", "scopeName", "values", "usedValues", "getCode", "valueCode", "code", "nameSet", "def", "code_1", "scope_1", "code_2", "exports", "scope_2", "Node", "_names", "_constants", "Def", "varKind", "name", "rhs", "es5", "_n", "names", "constants", "optimizeExpr", "Assign", "lhs", "sideEffects", "addExprNames", "AssignOp", "op", "Label", "label", "Break", "Throw", "error", "AnyCode", "code", "ParentNode", "nodes", "opts", "i", "n", "subtractNames", "addNames", "BlockNode", "Root", "Else", "If", "_If", "condition", "cond", "e", "ns", "not", "_a", "For", "ForLoop", "iteration", "ForRange", "from", "to", "ForIter", "loop", "iterable", "Func", "args", "async", "Return", "Try", "_b", "Catch", "Finally", "CodeGen", "extScope", "prefix", "prefixOrName", "value", "keyOrRef", "scopeName", "nameOrPrefix", "constant", "_constant", "c", "keyValues", "key", "thenBody", "elseBody", "node", "forBody", "arr", "obj", "tryBody", "catchCode", "finallyCode", "body", "nodeCount", "len", "toClose", "funcBody", "N1", "N2", "expr", "replaceName", "canOptimize", "items", "x", "par", "andCode", "mappend", "and", "orCode", "or", "y", "codegen_1", "code_1", "toHash", "arr", "hash", "item", "exports", "alwaysValidSchema", "it", "schema", "checkUnknownRules", "schemaHasRules", "opts", "self", "rules", "key", "checkStrictMode", "schemaHasRulesButRef", "RULES", "schemaRefOrVal", "topSchemaRef", "schemaPath", "keyword", "$data", "unescapeFragment", "str", "unescapeJsonPointer", "escapeFragment", "escapeJsonPointer", "eachItem", "xs", "f", "x", "makeMergeEvaluated", "mergeNames", "mergeToName", "mergeValues", "resultToName", "gen", "from", "to", "toName", "res", "setEvaluated", "evaluatedPropsToName", "items", "ps", "props", "p", "snippets", "useFunc", "Type", "getErrorPath", "dataProp", "dataPropType", "jsPropertySyntax", "isNumber", "msg", "mode", "codegen_1", "names", "exports", "codegen_1", "util_1", "names_1", "exports", "keyword", "schemaType", "reportError", "cxt", "error", "errorPaths", "overrideAllErrors", "it", "gen", "compositeRule", "allErrors", "errObj", "errorObjectCode", "addError", "returnErrors", "reportExtraError", "resetErrorsCount", "errsCount", "extendErrors", "schemaValue", "data", "err", "i", "errs", "validateName", "schemaEnv", "E", "createErrors", "errorObject", "keyValues", "errorInstancePath", "errorSchemaPath", "extraErrorProps", "errorPath", "instancePath", "instPath", "errSchemaPath", "schemaPath", "parentSchema", "schPath", "params", "message", "opts", "propertyName", "topSchemaRef", "errors_1", "codegen_1", "names_1", "boolError", "topBoolOrEmptySchema", "it", "gen", "schema", "validateName", "falseSchemaError", "exports", "boolOrEmptySchema", "valid", "overrideAllErrors", "data", "cxt", "_jsonTypes", "jsonTypes", "isJSONType", "x", "exports", "getRules", "groups", "schemaHasRulesForType", "schema", "self", "type", "group", "shouldUseGroup", "exports", "rule", "shouldUseRule", "_a", "kwd", "rules_1", "applicability_1", "errors_1", "codegen_1", "util_1", "DataType", "exports", "getSchemaTypes", "schema", "types", "getJSONTypes", "ts", "coerceAndCheckDataType", "it", "gen", "data", "opts", "coerceTo", "coerceToTypes", "checkTypes", "wrongType", "checkDataTypes", "coerceData", "reportTypeError", "COERCIBLE", "coerceTypes", "t", "dataType", "coerced", "coerceSpecificType", "assignParentData", "parentData", "parentDataProperty", "expr", "checkDataType", "strictNums", "correct", "EQ", "cond", "numCond", "_cond", "dataTypes", "notObj", "typeError", "schemaValue", "cxt", "getTypeErrorContext", "schemaCode", "codegen_1", "util_1", "assignDefaults", "it", "ty", "properties", "items", "key", "assignDefault", "sch", "i", "exports", "prop", "defaultValue", "gen", "compositeRule", "data", "opts", "childData", "condition", "codegen_1", "util_1", "names_1", "util_2", "checkReportMissingProp", "cxt", "prop", "gen", "data", "it", "noPropertyInData", "exports", "checkMissingProp", "opts", "properties", "missing", "reportMissingProp", "hasPropFunc", "isOwnProperty", "property", "propertyInData", "ownProperties", "cond", "allSchemaProperties", "schemaMap", "p", "schemaProperties", "callValidateCode", "schemaCode", "topSchemaRef", "schemaPath", "errorPath", "func", "context", "passSchema", "dataAndSchema", "valCxt", "args", "newRegExp", "usePattern", "pattern", "u", "regExp", "rx", "validateArray", "keyword", "valid", "validArr", "validateItems", "notValid", "len", "i", "validateUnion", "schema", "sch", "schValid", "_sch", "schCxt", "codegen_1", "names_1", "code_1", "errors_1", "macroKeywordCode", "cxt", "def", "gen", "keyword", "schema", "parentSchema", "it", "macroSchema", "schemaRef", "useKeyword", "valid", "exports", "funcKeywordCode", "$data", "checkAsyncKeyword", "validate", "validateRef", "validateKeyword", "_a", "assignValid", "modifyData", "reportErrs", "ruleErrs", "validateAsync", "validateSync", "addErrs", "e", "validateErrs", "_await", "passCxt", "passSchema", "errors", "data", "errs", "schemaEnv", "result", "validSchemaType", "schemaType", "allowUndefined", "st", "validateKeywordUsage", "opts", "self", "errSchemaPath", "deps", "kwd", "msg", "codegen_1", "util_1", "getSubschema", "it", "keyword", "schemaProp", "schema", "schemaPath", "errSchemaPath", "topSchemaRef", "sch", "exports", "extendSubschemaData", "subschema", "dataProp", "dpType", "data", "dataTypes", "propertyName", "gen", "errorPath", "dataPathArr", "opts", "nextData", "dataContextProps", "_nextData", "extendSubschemaMode", "jtdDiscriminator", "jtdMetadata", "compositeRule", "createErrors", "allErrors", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "keys", "key", "require_json_schema_traverse", "__commonJSMin", "exports", "module", "traverse", "schema", "opts", "cb", "pre", "post", "_traverse", "jsonPtr", "rootSchema", "parentJsonPtr", "parentKeyword", "parentSchema", "keyIndex", "key", "sch", "i", "prop", "escapeJsonPtr", "str", "util_1", "equal", "traverse", "SIMPLE_INLINED", "inlineRef", "schema", "limit", "hasRef", "countKeys", "exports", "REF_KEYWORDS", "key", "sch", "count", "getFullPath", "resolver", "id", "normalize", "normalizeId", "p", "_getFullPath", "TRAILING_SLASH_HASH", "resolveUrl", "baseId", "ANCHOR", "getSchemaRefs", "schemaId", "uriResolver", "schId", "baseIds", "pathPrefix", "localRefs", "schemaRefs", "jsonPtr", "_", "parentJsonPtr", "fullPath", "innerBaseId", "addRef", "addAnchor", "ref", "_resolve", "ambiguos", "schOrRef", "checkAmbiguosRef", "anchor", "sch1", "sch2", "boolSchema_1", "dataType_1", "applicability_1", "dataType_2", "defaults_1", "keyword_1", "subschema_1", "codegen_1", "names_1", "resolve_1", "util_1", "errors_1", "validateFunctionCode", "it", "isSchemaObj", "checkKeywords", "schemaCxtHasRules", "topSchemaObjCode", "validateFunction", "exports", "gen", "validateName", "schema", "schemaEnv", "opts", "body", "funcSourceUrl", "destructureValCxtES5", "destructureValCxt", "commentKeyword", "checkNoDefault", "resetEvaluated", "typeAndKeywords", "returnResults", "schId", "subschemaCode", "valid", "subSchemaObjCode", "self", "key", "updateContext", "checkAsyncSchema", "errsCount", "checkRefsAndKeywords", "schemaKeywords", "types", "checkedTypes", "errSchemaPath", "msg", "schemaPath", "rootName", "ValidationError", "assignEvaluated", "evaluated", "props", "items", "typeErrors", "data", "allErrors", "RULES", "keywordCode", "checkStrictTypes", "group", "groupKeywords", "iterateKeywords", "useDefaults", "rule", "checkContextTypes", "checkMultipleTypes", "checkKeywordTypes", "t", "includesType", "strictTypesError", "narrowSchemaTypes", "ts", "rules", "keyword", "type", "hasApplicableType", "schTs", "kwdT", "withTypes", "KeywordCxt", "def", "getData", "condition", "successAction", "failAction", "schemaCode", "append", "errorParams", "errorPaths", "cond", "obj", "assign", "codeBlock", "$dataValid", "schemaType", "wrong$DataType", "invalid$DataSchema", "st", "validateSchemaRef", "appl", "subschema", "nextContext", "schemaCxt", "toName", "ruleType", "cxt", "JSON_POINTER", "RELATIVE_JSON_POINTER", "$data", "dataLevel", "dataNames", "dataPathArr", "jsonPointer", "matches", "up", "errorMsg", "expr", "segments", "segment", "pointerType", "ValidationError", "errors", "exports", "resolve_1", "MissingRefError", "resolver", "baseId", "ref", "msg", "exports", "codegen_1", "validation_error_1", "names_1", "resolve_1", "util_1", "validate_1", "SchemaEnv", "env", "schema", "_a", "exports", "compileSchema", "sch", "_sch", "getCompilingSchema", "rootId", "es5", "lines", "ownProperties", "gen", "_ValidationError", "validateName", "schemaCxt", "sourceCode", "validateCode", "validate", "props", "items", "e", "resolveRef", "root", "baseId", "ref", "schOrFunc", "resolve", "schemaId", "inlineOrCompile", "schEnv", "sameSchemaEnv", "s1", "s2", "resolveSchema", "p", "refPath", "getJsonPointer", "id", "schOrRef", "schId", "PREVENT_SCOPE_CHANGE", "parsedRef", "part", "partSchema", "$ref", "require_data", "__commonJSMin", "exports", "module", "require_scopedChars", "__commonJSMin", "exports", "module", "HEX", "require_utils", "__commonJSMin", "exports", "module", "HEX", "normalizeIPv4", "host", "findToken", "matches", "address", "stripLeadingZeros", "stringArrayToHexStripped", "input", "keepZero", "acc", "strip", "c", "getIPV6", "tokenCount", "output", "buffer", "isZone", "endipv6Encountered", "endIpv6", "consume", "hex", "i", "cursor", "normalizeIPv6", "opts", "ipv6", "newHost", "escapedHost", "str", "token", "out", "skip", "l", "ind", "RDS1", "RDS2", "RDS3", "RDS5", "removeDotSegments", "im", "s", "normalizeComponentEncoding", "components", "esc", "func", "recomposeAuthority", "options", "uriTokens", "ipV4res", "ipV6res", "require_schemes", "__commonJSMin", "exports", "module", "UUID_REG", "URN_REG", "isSecure", "wsComponents", "httpParse", "components", "httpSerialize", "secure", "wsParse", "wsSerialize", "path", "query", "urnParse", "urnComponents", "options", "matches", "scheme", "urnScheme", "schemeHandler", "SCHEMES", "urnSerialize", "nid", "uriComponents", "nss", "urnuuidParse", "uuidComponents", "urnuuidSerialize", "http", "https", "ws", "wss", "urn", "urnuuid", "require_fast_uri", "__commonJSMin", "exports", "module", "normalizeIPv6", "normalizeIPv4", "removeDotSegments", "recomposeAuthority", "normalizeComponentEncoding", "SCHEMES", "normalize", "uri", "options", "serialize", "parse", "resolve", "baseURI", "relativeURI", "schemelessOptions", "resolved", "resolveComponents", "base", "relative", "skipNormalization", "target", "equal", "uriA", "uriB", "cmpts", "opts", "components", "uriTokens", "schemeHandler", "authority", "s", "hexLookUp", "v", "k", "nonSimpleDomain", "value", "code", "i", "len", "URI_PARSE", "parsed", "gotEncoding", "isIP", "matches", "ipv4result", "ipv6result", "e", "fastUri", "uri", "exports", "validate_1", "exports", "codegen_1", "validation_error_1", "ref_error_1", "rules_1", "compile_1", "codegen_2", "resolve_1", "dataType_1", "util_1", "$dataRefSchema", "uri_1", "defaultRegExp", "str", "flags", "META_IGNORE_OPTIONS", "EXT_SCOPE_NAMES", "removedOptions", "deprecatedOptions", "MAX_EXPRESSION", "requiredOptions", "o", "s", "_optz", "_a", "optimize", "regExp", "_c", "_b", "uriResolver", "_d", "_f", "_e", "_h", "_g", "_k", "_j", "_m", "_l", "_p", "_o", "_q", "_r", "_s", "_t", "_u", "_v", "_w", "_x", "_y", "_z", "_0", "Ajv", "opts", "es5", "lines", "getLogger", "formatOpt", "checkOptions", "getMetaSchemaOptions", "addInitialFormats", "addInitialKeywords", "addInitialSchemas", "$data", "meta", "schemaId", "_dataRefSchema", "schemaKeyRef", "data", "v", "valid", "schema", "_meta", "sch", "loadSchema", "runCompileAsync", "_schema", "loadMetaSchema", "_compileAsync", "$ref", "e", "checkLoaded", "loadMissingSchema", "ref", "missingRef", "_loadSchema", "p", "key", "_validateSchema", "id", "throwOrLogError", "$schema", "message", "keyRef", "getSchEnv", "root", "cacheKey", "definitions", "def", "kwdOrDef", "keyword", "checkKeyword", "kwd", "addRule", "keywordMetaschema", "definition", "k", "t", "rule", "RULES", "group", "name", "format", "errors", "separator", "dataVar", "text", "msg", "metaSchema", "keywordsJsonPointers", "rules", "jsonPointer", "segments", "keywords", "seg", "schemaOrData", "schemas", "regex", "baseId", "validateSchema", "addSchema", "localRefs", "currentOpts", "checkOpts", "options", "log", "opt", "optsSchemas", "defs", "metaOpts", "noLogs", "logger", "KEYWORD_NAME", "dataType", "post", "ruleGroup", "addBeforeRule", "before", "i", "_rule", "$dataRef", "def", "exports", "ref_error_1", "code_1", "codegen_1", "names_1", "compile_1", "util_1", "def", "cxt", "gen", "$ref", "it", "baseId", "env", "validateName", "opts", "self", "root", "callRootRef", "schOrEnv", "callValidate", "inlineRefSchema", "callRef", "rootName", "sch", "v", "getValidate", "schName", "valid", "schCxt", "exports", "$async", "allErrors", "passCxt", "callAsyncRef", "callSyncRef", "addEvaluatedFrom", "e", "addErrorsFrom", "source", "errs", "schEvaluated", "_a", "props", "items", "id_1", "ref_1", "core", "exports", "codegen_1", "ops", "KWDs", "error", "keyword", "schemaCode", "def", "cxt", "data", "exports", "codegen_1", "error", "schemaCode", "def", "cxt", "gen", "data", "it", "prec", "res", "invalid", "exports", "ucs2length", "str", "len", "length", "pos", "value", "exports", "codegen_1", "util_1", "ucs2length_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "it", "op", "len", "exports", "code_1", "codegen_1", "error", "schemaCode", "def", "cxt", "data", "$data", "schema", "it", "u", "regExp", "exports", "codegen_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "op", "exports", "code_1", "codegen_1", "util_1", "error", "missingProperty", "def", "cxt", "gen", "schema", "schemaCode", "data", "$data", "it", "opts", "useLoop", "allErrorsMode", "exitOnErrorMode", "props", "definedProperties", "requiredKey", "schemaPath", "msg", "loopAllRequired", "prop", "missing", "valid", "loopUntilMissing", "exports", "codegen_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "op", "exports", "equal", "exports", "dataType_1", "codegen_1", "util_1", "equal_1", "error", "i", "j", "def", "cxt", "gen", "data", "$data", "schema", "parentSchema", "schemaCode", "it", "valid", "itemTypes", "validateUniqueItems", "canOptimize", "loopN", "loopN2", "t", "item", "wrongType", "indices", "eql", "outer", "exports", "codegen_1", "util_1", "equal_1", "error", "schemaCode", "def", "cxt", "gen", "data", "$data", "schema", "exports", "codegen_1", "util_1", "equal_1", "error", "schemaCode", "def", "cxt", "gen", "data", "$data", "schema", "it", "useLoop", "eql", "getEql", "valid", "loopEnum", "vSchema", "_x", "i", "equalCode", "v", "sch", "exports", "limitNumber_1", "multipleOf_1", "limitLength_1", "pattern_1", "limitProperties_1", "required_1", "limitItems_1", "uniqueItems_1", "const_1", "enum_1", "validation", "exports", "codegen_1", "util_1", "error", "len", "def", "cxt", "parentSchema", "it", "items", "validateAdditionalItems", "gen", "schema", "data", "keyword", "valid", "validateItems", "i", "exports", "codegen_1", "util_1", "code_1", "def", "cxt", "schema", "it", "validateTuple", "extraItems", "schArr", "gen", "parentSchema", "data", "keyword", "checkStrictTuple", "valid", "len", "sch", "i", "opts", "errSchemaPath", "fullTuple", "msg", "exports", "items_1", "def", "cxt", "exports", "codegen_1", "util_1", "code_1", "additionalItems_1", "error", "len", "def", "cxt", "schema", "parentSchema", "it", "prefixItems", "exports", "codegen_1", "util_1", "error", "min", "max", "def", "cxt", "gen", "schema", "parentSchema", "data", "it", "minContains", "maxContains", "len", "cond", "valid", "validateItems", "validateItemsWithCount", "schValid", "count", "checkLimits", "_valid", "block", "i", "exports", "codegen_1", "util_1", "code_1", "exports", "property", "depsCount", "deps", "property_ies", "missingProperty", "def", "cxt", "propDeps", "schDeps", "splitDependencies", "validatePropertyDeps", "validateSchemaDeps", "schema", "propertyDeps", "schemaDeps", "key", "gen", "data", "it", "missing", "prop", "hasProperty", "depProp", "keyword", "valid", "schCxt", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "data", "it", "valid", "key", "exports", "code_1", "codegen_1", "names_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "parentSchema", "data", "errsCount", "it", "allErrors", "opts", "props", "patProps", "checkAdditionalProperties", "key", "additionalPropertyCode", "isAdditional", "definedProp", "propsSchema", "p", "deleteAdditional", "valid", "applyAdditionalSchema", "errors", "subschema", "exports", "validate_1", "code_1", "util_1", "additionalProperties_1", "def", "cxt", "gen", "schema", "parentSchema", "data", "it", "allProps", "prop", "properties", "p", "valid", "hasDefault", "applyPropertySchema", "exports", "code_1", "codegen_1", "util_1", "util_2", "def", "cxt", "gen", "schema", "data", "parentSchema", "it", "opts", "patterns", "alwaysValidPatterns", "checkProperties", "valid", "props", "validatePatternProperties", "pat", "checkMatchingProperties", "validateProperties", "prop", "key", "alwaysValid", "exports", "util_1", "def", "cxt", "gen", "schema", "it", "valid", "exports", "code_1", "def", "exports", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "parentSchema", "it", "schArr", "valid", "passing", "schValid", "validateOneOf", "sch", "i", "schCxt", "exports", "util_1", "def", "cxt", "gen", "schema", "it", "valid", "sch", "i", "schCxt", "exports", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "parentSchema", "it", "hasThen", "hasSchema", "hasElse", "valid", "schValid", "validateIf", "ifClause", "validateClause", "schCxt", "keyword", "schema", "exports", "util_1", "def", "keyword", "parentSchema", "it", "exports", "additionalItems_1", "prefixItems_1", "items_1", "items2020_1", "contains_1", "dependencies_1", "propertyNames_1", "additionalProperties_1", "properties_1", "patternProperties_1", "not_1", "anyOf_1", "oneOf_1", "allOf_1", "if_1", "thenElse_1", "getApplicator", "draft2020", "applicator", "exports", "codegen_1", "error", "schemaCode", "def", "cxt", "ruleType", "gen", "data", "$data", "schema", "it", "opts", "errSchemaPath", "schemaEnv", "self", "validate$DataFormat", "validateFormat", "fmts", "fDef", "fType", "format", "unknownFmt", "invalidFmt", "callFormat", "validData", "formatDef", "unknownFormat", "fmtType", "fmtRef", "getFormat", "validCondition", "unknownMsg", "fmtDef", "code", "fmt", "exports", "format_1", "format", "exports", "exports", "core_1", "validation_1", "applicator_1", "format_1", "metadata_1", "draft7Vocabularies", "exports", "DiscrError", "exports", "codegen_1", "types_1", "compile_1", "ref_error_1", "util_1", "error", "discrError", "tagName", "tag", "def", "cxt", "gen", "data", "schema", "parentSchema", "it", "oneOf", "valid", "validateMapping", "mapping", "getMapping", "tagValue", "applyTagSchema", "schemaProp", "_valid", "schCxt", "oneOfMapping", "topRequired", "hasRequired", "tagRequired", "i", "sch", "ref", "propSch", "_a", "addMappings", "required", "addMapping", "exports", "require_json_schema_draft_07", "__commonJSMin", "exports", "module", "core_1", "draft7_1", "discriminator_1", "draft7MetaSchema", "META_SUPPORT_DATA", "META_SCHEMA_ID", "Ajv", "v", "metaSchema", "exports", "module", "validate_1", "codegen_1", "validation_error_1", "ref_error_1", "codegen_1", "TYPES", "getDef", "cxt", "data", "schema", "schemaValue", "exports", "module", "typeof_1", "__importDefault", "typeofPlugin", "ajv", "exports", "module", "CONSTRUCTORS", "getDef", "_getDef", "schema", "C", "getConstructor", "data", "constructors", "c", "exports", "module", "instanceof_1", "__importDefault", "instanceofPlugin", "ajv", "exports", "module", "getRangeDef", "keyword", "min", "max", "validateRangeSchema", "exports", "_range_1", "__importDefault", "getDef", "exports", "module", "range_1", "__importDefault", "range", "ajv", "exports", "module", "_range_1", "__importDefault", "getDef", "exports", "module", "exclusiveRange_1", "__importDefault", "exclusiveRange", "ajv", "exports", "module", "codegen_1", "META_SCHEMA_ID", "metaSchemaRef", "defaultMeta", "exports", "usePattern", "gen", "opts", "pattern", "flags", "rx", "codegen_1", "_util_1", "regexpMetaSchema", "metaRegexp", "getDef", "cxt", "data", "schema", "regx", "getRegExp", "sch", "rx", "exports", "module", "regexp_1", "__importDefault", "regexp", "ajv", "exports", "module", "codegen_1", "transform", "s", "cfg", "configKey", "getDef", "_getDef", "cxt", "gen", "data", "schema", "parentSchema", "it", "parentData", "parentDataProperty", "tNames", "config", "getEnumCaseCfg", "transformExpr", "ts", "t", "func", "arg", "v", "k", "exports", "module", "transform_1", "__importDefault", "transform", "ajv", "exports", "module", "equal", "SCALAR_TYPES", "getDef", "keys", "parentSchema", "scalar", "getScalarKeys", "data", "k", "key", "hash", "x", "p", "i", "j", "y", "exports", "schema", "t", "_c", "_b", "_a", "module", "uniqueItemProperties_1", "__importDefault", "uniqueItemProperties", "ajv", "exports", "module", "getDef", "schema", "parentSchema", "required", "exports", "module", "allRequired_1", "__importDefault", "allRequired", "ajv", "exports", "module", "getRequiredDef", "keyword", "schema", "p", "exports", "_required_1", "__importDefault", "getDef", "exports", "module", "anyRequired_1", "__importDefault", "anyRequired", "ajv", "exports", "module", "_required_1", "__importDefault", "getDef", "exports", "module", "oneRequired_1", "__importDefault", "oneRequired", "ajv", "exports", "module", "codegen_1", "_util_1", "error", "missingPattern", "getDef", "cxt", "gen", "schema", "data", "valid", "pat", "validateProperties", "pattern", "matched", "key", "exports", "module", "patternRequired_1", "__importDefault", "patternRequired", "ajv", "exports", "module", "getDef", "schema", "p", "exports", "module", "prohibited_1", "__importDefault", "prohibited", "ajv", "exports", "module", "_util_1", "getDef", "opts", "schema", "allOf", "pointer", "getSchema", "exports", "jsonPointer", "segments", "rootSchema", "pointerSchema", "i", "segment", "isLast", "unescapeJsonPointer", "properties", "items", "count", "str", "module", "deepProperties_1", "__importDefault", "deepProperties", "ajv", "opts", "exports", "module", "codegen_1", "getDef", "ctx", "schema", "data", "props", "jp", "getData", "jsonPointer", "segments", "x", "xs", "s", "i", "unescapeJPSegment", "exports", "module", "deepRequired_1", "__importDefault", "deepRequired", "ajv", "exports", "module", "sequences", "DEFAULTS", "args", "max", "_a", "name", "getDef", "_getDef", "schema", "_parentSchema", "it", "fs", "key", "getDefault", "empty", "data", "prop", "d", "getObjDefault", "getStrDefault", "func", "def", "assertDefined", "exports", "module", "dynamicDefaults_1", "__importDefault", "dynamicDefaults", "ajv", "exports", "module", "codegen_1", "_util_1", "error", "schemaProp", "getDef", "opts", "metaSchema", "cxt", "gen", "schemaCode", "parentSchema", "valid", "schValid", "value", "schCxt", "exports", "module", "select_1", "__importDefault", "select", "ajv", "opts", "d", "exports", "module", "typeof_1", "__importDefault", "instanceof_1", "range_1", "exclusiveRange_1", "regexp_1", "transform_1", "uniqueItemProperties_1", "allRequired_1", "anyRequired_1", "oneRequired_1", "patternRequired_1", "prohibited_1", "deepProperties_1", "deepRequired_1", "dynamicDefaults_1", "select_1", "ajvKeywords", "exports", "module", "keywords_1", "__importDefault", "ajvKeywords", "ajv", "keyword", "k", "get", "defFunc", "exports", "module", "fmtDef", "validate", "compare", "exports", "date", "compareDate", "time", "compareTime", "date_time", "compareDateTime", "uri", "regex", "byte", "validateInt32", "validateInt64", "validateNumber", "isLeapYear", "year", "DATE", "DAYS", "str", "matches", "month", "day", "d1", "d2", "TIME", "withTimeZone", "hour", "minute", "second", "timeZone", "t1", "t2", "a1", "a2", "DATE_TIME_SEPARATOR", "dateTime", "dt1", "dt2", "res", "NOT_URI_FRAGMENT", "URI", "BYTE", "MIN_INT32", "MAX_INT32", "value", "Z_ANCHOR", "ajv_1", "codegen_1", "ops", "KWDs", "error", "keyword", "schemaCode", "exports", "cxt", "gen", "data", "it", "opts", "self", "fCxt", "validate$DataFormat", "validateFormat", "fmts", "fmt", "compareCode", "format", "fmtDef", "formatLimitPlugin", "ajv", "formats_1", "limit_1", "codegen_1", "fullName", "fastName", "formatsPlugin", "ajv", "opts", "addFormats", "formats", "exportName", "list", "name", "mode", "f", "fs", "_a", "_b", "module", "exports", "require_absolutePath", "__commonJSMin", "exports", "errorMessage", "message", "schema", "data", "getErrorFor", "shouldBeAbsolute", "addAbsolutePathKeyword", "ajv", "parentSchema", "callback", "passes", "_default", "require_undefinedAsNull", "__commonJSMin", "exports", "addUndefinedAsNullKeyword", "ajv", "kwVal", "data", "metadata", "dataCxt", "idx", "_default", "require_validate", "__commonJSMin", "exports", "_ValidationError", "disableValidation", "enableValidation", "needValidate", "validate", "_interopRequireDefault", "_memorize", "obj", "getAjv", "Ajv", "ajvKeywords", "addFormats", "ajv", "addAbsolutePathKeyword", "addUndefinedAsNullKeyword", "applyPrefix", "error", "idx", "err", "skipValidation", "value", "schema", "options", "configuration", "errors", "validateObject", "compiledSchema", "filterErrors", "newErrors", "instancePath", "children", "oldError", "require_dist", "__commonJSMin", "exports", "module", "validate", "ValidationError", "enableValidation", "disableValidation", "needValidate", "require_utils", "__commonJSMin", "exports", "module", "validate", "validateOptions", "options", "schema", "processOptions", "processors", "processedOptions", "property", "processor", "require_schema", "__commonJSMin", "exports", "module", "require_processors", "__commonJSMin", "exports", "module", "path", "ROOT_DIR_TAG", "CWD", "value", "require_webpack_plugin", "__commonJSMin", "exports", "module", "path", "utils", "PLUGIN_NAME", "OPTIONS_SCHEMA", "OPTIONS_PROCESSORS", "options", "compiler", "factory", "resolveData", "require_src", "__commonJSMin", "exports", "module", "fs", "Filer"]
}
